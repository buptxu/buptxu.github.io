[{"title":"JSON的一些理解","date":"2017-04-19T03:02:11.000Z","path":"2017/04/19/JSON的一些理解/","text":"使用JSON中注意的问题和JS中JSON.stringify、JSON.parse、以及不常见的toJSON的方法 先来看一个JS中常见的JS对象序列化成JSON字符串的问题，请问，以下JS对象通过JSON.stringify后的字符串是怎样的？先不要急着复制粘贴到控制台，先自己打开一个代码编辑器或者纸，写写看，写完再去仔细对比你的控制台输出，会返回什么呢?12345678910var friend=&#123; firstName: 'Good', 'lastName': 'Man', 'address': undefined, 'phone': [\"1234567\",undefined], 'fullName': function()&#123; return this.firstName + ' ' + this.lastName; &#125;&#125;;JSON.stringify(friend);//会返回什么呢？ 如果我想在最终JSON字符串将这个’friend’的姓名全部变成大写字母，也就是把”Good”变成”GOOD”，把”Man”变成”MAN”，那么可以怎么做？ 看完上面两个问题，我们再追本溯源看一下，JSON究竟是什么东西？为什么JSON易于数据交换？JSON和JS对象的区别？JS中JSON.parse、JSON.stringify和不常见的toJSON，这几个函数的参数和处理细节到底是怎样的？ 一、JSON是一种格式，基于文本，优于轻量，用于交换数1. 一种数据格式什么是格式？就是规范你的数据要怎么表示，举个栗子，有个人叫“二百六”，身高“160cm”，体重“60kg”，现在你要将这个人的这些信息传给别人或者别的什么东西，你有很多种选择： 姓名“二百六”，身高“160cm”，体重“60kg” name=”二百六”&amp;height=”160cm”&amp;weight=”60kg”&lt;person&gt;&lt;name&gt;二百六&lt;/name&gt;&lt;height&gt;160&lt;/height&gt;&lt;weight&gt;60&lt;/weight&gt;&lt;/person&gt; {“name”:”二百六”,”height”:160,”weight”:60} … … 以上所有选择，传递的数据是一样的，但是你可以看到形式是可以各式各样的，这就是各种不同格式化后的数据，JSON是其中一种表示方式。 2.基于文本的数据格式JSON是基于文本的数据格式，相对于基于二进制的数据，所以JSON在传递的时候是传递符合JSON这种格式(至于JSON的格式是什么，第二部分再说)的字符串，我们常会称为“JSON字符串”。 3.轻量级的数据格式在JSON之前，有一个数据格式叫xml，现在还是广泛在用，但是JSON更加轻量，如xml需要用到很多标签，像上面的例子中，你可以明显看到xml格式的数据中标签本身占据了很多空间，而JSON比较轻量，相同数据，以JSON的格式占据的带宽更小，这在有大量数据请求和传递的情况下是有明显优势的。 4.被广泛地用于数据交换轻量已经是一个用于数据交换的优势了，但更重要的JSON是易于阅读、编写和机器解析的，即这个JSON对人和机器都是友好的，而且又轻，独立于语言（因为是基于文本的），所以JSON被广泛用于数据交换。 以前端JS进行ajax的POST请求为例，后端PHP处理请求为例： 前端构造一个JS对象，用于包装要传递的数据，然后将JS对象转化为JSON字符串，再发送请求到后端； 后端PHP接收到这个JSON字符串，将JSON字符串转化为PHP对象，然后处理请求。 可以看到，相同的数据在这里有3种不同的表现形式，分别是前端的JS对象、传输的JSON字符串、后端的PHP对象，JS对象和PHP对象明显不是一个东西，但是由于大家用的都是JSON来传递数据，大家都能理解这种数据格式，都能把JSON这种数据格式很容易地转化为自己能理解的数据结构，这就方便啦，在其他各种语言环境中交换数据都是如此。 二、JSON和JS对象之间的关系经常看到“JSON是JS的一个子集”这句话，而且这句话我曾经也这么认为，每个符合JSON格式的字符串你解析成js都是可以的，直到后来发现了一个奇奇怪怪的东西… 1. 两个本质不同的东西为什么那么密切JSON和JS对象本质上完全不是同一个东西，就像“斑马线”和“斑马”，“斑马线”基于“斑马”身上的条纹来呈现和命名，但是斑马是活的，斑马线是非生物。 同样，”JSON”全名”JavaScript Object Notation”，所以它的格式（语法）是基于JS的，但它就是一种格式，而JS对象是一个实例，是存在于内存的一个东西。 说句玩笑话，如果JSON是基于PHP的，可能就叫PON了，形式可能就是这样的了[‘propertyOne’ =&gt; ‘foo’, ‘propertyTwo’ =&gt; 42]，如果这样，那么JSON可能现在是和PHP比较密切了。 此外，JSON是可以传输的，因为它是文本格式，但是JS对象是没办法传输的，在语法上，JSON也会更加严格，但是JS对象就很松散了。 那么两个不同的东西为什么那么密切，因为JSON毕竟是从JS中演变出来的，语法相近。 2. JSON格式别JS对象语法表现上严格在哪先就以“键值对为表现的对象”形式上，对比下两者的不同，至于JSON还能以怎样的形式表现，对比完后再罗列。 对比内容 JSON js 键名 必须加双引号 可不加或单双引号 属性值 10进制数值、字符串、布尔值、null、数组、符合JSON格式的对象、不能是函数、NAN、infinity、-infinity、undefined 无限制 逗号 最后一个不加逗号 无限制 数值 前导0不能用，小数点后必须有数字 无限制 可以看到，相对于JS对象，JSON的格式更严格，所以大部分写的JS对象是不符合JSON的格式的。 来看看例子：12345678910111213141516171819202122// 这只是 JS 对象var JSON_obj1 = &#123;&#125;; // JSON 格式的 JavaScript 对象 var JSON_obj2 = &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;;// JSON 格式的字符串var JSON_str1 = '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;';// JSON 格式的数组，是 JSON 的稍复杂一点的形式var JSON_arr = [ &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,];//稍复杂一点的 JSON 格式的字符串 var JSON_str2='['+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+']'; 另外，除了常见的“正常的”JSON格式，要么表现为一个对象形式{…}，要么表现为一个数组形式[…]，任何单独的一个10进制数值、双引号字符串、布尔值和null都是有效符合JSON格式的。 3. 一个有意思的地方，JSON不是JS的子集首先看下面的代码，你可以copy到控制台执行下：123var code = '\"\\u2028\\u2029\"'; JSON.parse(code); // 不报错eval(code); // 报错 这两个字符\\u2028和\\u2029分别表示行分隔符和段落分隔符，JSON.parse可以正常解析，但是当做js解析时会报错。 三、再来看看JS中的JSON函数在JS中我们主要会接触到两个JSON相关的函数，分别用于JSON字符串和JS数据结构之间的转化，一个叫JSON.stringify，它很聪明，聪明到你写的不符合JSON格式的JS对象都能帮你处理成符合JSON格式的字符串，所以你得知道它到底干了什么，免得它只是自作聪明，然后让你Debug long time；另一个叫JSON.parse，用于转化json字符串到JS数据结构，它很严格，你的JSON字符串如果构造地不对，是没办法解析的。 而它们的参数不止一个，虽然我们经常用的时候只传入一个参数。 此外，还有一个toJSON函数，我们较少看到，但是它会影响JSON.stringify。 1. 将JS数据结构转化为JSON字符串——JSON.stringify这个函数的函数签名是这样的：1JSON.stringify(value[, replacer [, space]]) 下面将分别展开带1~3个参数的用法，最后是它在序列化时做的一些“聪明”的事，要特别注意。 1.1 基本使用——仅需一个参数 这很简单，传入一个JSON格式的JS对象或者数组，JSON.stringify({“name”:”GoodMan”,”age”:18})返回一个字符串”{“name”:”Good Man”,”age”:18}”。 可以看到本身我们传入的这个JS对象就是符合JSON格式的，用的双引号，也没有JSON不接受的属性值，但如果像开头那个例子中的一样呢？不急，我们先举简单的例子来看看这个函数的几个参数的意义，再来说这个问题。 1.2 第二个参数可以是函数，也可以是一个数组 如果第二个参数是一个函数，那么序列化过程中的每个属性都会被这个函数转化和处理 如果第二个参数是一个数组，那么只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中 如果第二个参数是null，那作用上和空着没啥区别，但是不想设置第二个参数，只是想设置第三个参数的时候，就可以设置第二个参数为null 这第二个参数若是函数，看例子：123456789101112131415161718var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":\"1234567\", \"age\":18&#125;;var friendAfter=JSON.stringify(friend,function(key,value)&#123; if(key===\"phone\") return \"(010)\"+value; else if(typeof value === \"number\") return value + 10; else return value; //如果把这个else删除，那么结果会是undefined&#125;);console.log(friendAfter); //输出：&#123;\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":\"(010)1234567\",\"age\":28&#125; 如果制定了第二个参数是函数，那么这个函数必须对每一项都有返回，这个函数接受两个参数，一个键名，一个是属性值，函数必须针对每一个原来的属性值都要有新属性值的返回。 那么问题来了，如果传入的不是键值对的对象形式，而是方括号的数组形式呢？，比如上面的friend变成这样：friend=[“Jack”,”Rose”]，那么这个逐属性处理的函数接收到的key和value又是什么？如果是数组形式，那么key是索引，而value是这个数组项，你可以在控制台在这个函数内部打印出来这个key和value验证。 这第二个参数若是数组，看例子：123456789101112var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":\"1234567\", \"age\":18&#125;;//注意下面的数组有一个值并不是上面对象的任何一个属性名var friendAfter=JSON.stringify(friend,[\"firstName\",\"address\",\"phone\"]);console.log(friendAfter); //&#123;\"firstName\":\"Good\",\"phone\":\"1234567\"&#125;//注意看，指定的“address”由于没有在原来的对象中找到而被忽略 所以如果第二个参数是一个数组，那么只有在数组中出现的属性才会被序列化进结果字符串，只要在这个提供的数组中找不到的属性就不会被包含进去，而这个数组中存在但是源JS对象中不存在的属性会被忽略，不会报错。 1.3 第三个参数用于美化输出——不建议用 指定缩进用的空白字符，可以取以下几个值： 是1-10的某个数字，代表用几个空白字符 是字符串的话，就用该字符串代替空格，最多取这个字符串的前10个字符 没有提供该参数 等于 设置成null 等于 设置一个小于 1 的数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":&#123;\"home\":\"1234567\",\"work\":\"7654321\"&#125;&#125;;//直接转化是这样的：//&#123;\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":&#123;\"home\":\"1234567\",\"work\":\"7654321\"&#125;&#125;var friendAfter=JSON.stringify(friend,null,4); console.log(friendAfter); /*&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\": &#123; \"home\": \"1234567\", \"work\": \"7654321\" &#125;&#125;*/var friendAfter=JSON.stringify(friend,null,\"HAHAHAHA\"); console.log(friendAfter); /*&#123;HAHAHAHA\"firstName\": \"Good\", HAHAHAHA\"lastName\": \"Man\", HAHAHAHA\"phone\": &#123; HAHAHAHAHAHAHAHA\"home\": \"1234567\", HAHAHAHAHAHAHAHA\"work\": \"7654321\" HAHAHAHA&#125; &#125;*/var friendAfter=JSON.stringify(friend,null,\"WhatAreYouDoingNow\"); console.log(friendAfter); /* 最多只取10个字符&#123;WhatAreYou\"firstName\": \"Good\", WhatAreYou\"lastName\": \"Man\", WhatAreYou\"phone\": &#123; WhatAreYouWhatAreYou\"home\": \"1234567\", WhatAreYouWhatAreYou\"work\": \"7654321\" WhatAreYou&#125; &#125;*/ 但是别这样用，序列化是为了传输，传输当然是能越小越好，加莫名其妙的缩进符，解析困难（如果是字符串的话），也弱化了轻量化这个特点。。 1.4 注意这个函数的“小聪明”（注意） 如果有其他不确定的情况，那么最好的办法就是code，控制台看下输出就明了了。 键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号 最后一个属性后面有逗号的，会被自动去掉 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值也就是你的什么new String(“bala”)会变成”bala”，new Number(2017)会变成2017 undefined、任意的函数（其实有个函数会发生神奇的事，后面会说）以及 symbol 值（symbol详见ES6对symbol的介绍） 出现在非数组对象的属性值中：在序列化过程中会被忽略 出现在数组中时：被转换成 null1234JSON.stringify(&#123;x: undefined, y: function()&#123;return 1;&#125;, z: Symbol(\"\")&#125;); //出现在非数组对象的属性值中被忽略：\"&#123;&#125;\"JSON.stringify([undefined, Object, Symbol(\"\")]); //出现在数组对象的属性值中，变成null：\"[null,null,null]\" NaN、Infinity和-Infinity，不论在数组还是非数组的对象中，都被转化为null 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们 不可枚举的属性会被忽略 2.将JSON字符串解析为JS数据结构——JSON.parse这个函数的函数签名是这样的：1JSON.parse(text[, reviver]) 如果第一个参数，即JSON字符串不是合法的字符串的话，那么这个函数会抛出错误，所以如果你在写一个后端返回JSON字符串的脚本，最好调用语言本身的JSON字符串相关序列化函数，而如果是自己去拼接实现的序列化字符串，那么就尤其要注意序列化后的字符串是否是合法的，合法指这个JSON字符串完全符合JSON要求的严格格式。 值得注意的是这里有一个可选的第二个参数，这个参数必须是一个函数，这个函数作用在属性已经被解析但是还没返回前，将属性处理后再返回。123456789101112131415161718192021222324252627282930313233343536373839404142var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":&#123;\"home\":\"1234567\",\"work\":[\"7654321\",\"999000\"]&#125;&#125;;//我们先将其序列化var friendAfter=JSON.stringify(friend); //'&#123;\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":&#123;\"home\":\"1234567\",\"work\":[\"7654321\",\"999000\"]&#125;&#125;'//再将其解析出来，在第二个参数的函数中打印出key和valueJSON.parse(friendAfter,function(k,v)&#123; console.log(k); console.log(v); console.log(\"----\");&#125;);/*firstNameGood----lastNameMan----home1234567----07654321----1999000----work[ , ]----phone&#123;&#125;----&#123;&#125;----*/ 仔细看这些输出，可以发现这个遍历是由内而外的，可能由内而外这个词大家会误解，最里层是内部数组里的两个值啊，但是输出是从第一个属性开始的，怎么就是由内而外的呢？ 这个由内而外指的是对于复合属性来说的，通俗地讲，遍历的时候，从头到尾进行遍历，如果是简单属性值（数值、字符串、布尔值和null），那么直接遍历完成，如果是遇到属性值是对象或者数组形式的，那么暂停，先遍历这个子JSON，而遍历的原则也是一样的，等这个复合属性遍历完成，那么再完成对这个属性的遍历返回。本质上，这就是一个深度优先的遍历。 有两点需要注意： 如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。 你可以注意到上面例子最后一组输出看上去没有key，其实这个key是一个空字符串，而最后的object是最后解析完成对象，因为到了最上层，已经没有真正的属性了。 3.影响 JSON.stringify 的神奇函数——object.toJSON如果你在一个JS对象上实现了toJSON方法，那么调用JSON.stringify去序列化这个JS对象时，JSON.stringify直接调用这个对象的toJSON方法，将其返回的值作为参数去进行序列化。1234567891011var info=&#123; \"msg\":\"I Love You\", \"toJSON\":function()&#123; var replaceMsg=new Object(); replaceMsg[\"msg\"]=\"Go Die\"; return replaceMsg; &#125;&#125;;JSON.stringify(info); //返回的是：&#123;\"msg\":\"Go Die\"&#125;,说好的忽略函数呢,所以说它很神奇 类似的，Date类型可以直接传给JSON.stringify做参数，其中的原理就是，Date类型内置了toJSON方法。 四、关于兼容性的问题遗憾的是，以上所用的3个函数，不兼容IE7以及IE7之前的浏览器。有关兼容性的讨论，留待之后吧。如果想直接在应用上解决兼容性，那么可以套用JSON官方的js来解决。 本文是看到网上的文章整理出来的，原作者@Stinson Zhao","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"BFC","date":"2017-04-08T09:09:12.000Z","path":"2017/04/08/BFC与外边距折叠/","text":"块级格式化上下文(BFC)与边距折叠 需要注意的是切忌把触发BFC与消除边距折叠等同。 块级格式化上下文，Block formatting context(简称BFC)，规定了块级盒子的渲染布局方式，他在计算盒子高度，margin值计算等地方有区别于其他环境。CSS标准里的描述： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. BFC有什么特点 内部盒子会在垂直方向排列 同一个BFC中的元素可能会发生margin collapse BFC就是页面上的一个隔离的独立容器，里外互相不影响 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算 浮动盒区域不叠加到BFC上 什么元素会触发产生一个新的BFC 根元素 float属性不为none position为absolute或fixed display为inline­block, table­cell, table­caption, flex, inline­flex overflow不为visible认真看下面的例子：我们可以用BFC来干嘛 清除浮动 阻止边距折叠 用于布局，什么两栏自适应高度之类的 BFC兼容性IE6，7不支持BFC，而是使用私有属性hasLayout。表现上来看hasLayout和BFC相似，触发hasLayout条件与BFC相似，另外需要为元素设置IE特有的CSS属性zoom:1;zoom用于设置或检索元素的缩放比例，值为1即使用元素实际尺寸，使用zoom既可以触发hasLayout又不会对元素产生其他影响，相对来说更加方便 collapsing margins（边距折叠） 什么时候发生外边距折叠：垂直方向上的处于同一个BFC上的相邻外边距。 相邻意味着没有被padding、border、行框和clearance分隔开（clearance就是clear引起的位移，比如一个浮动元素50px高，他后面跟了一个设置了clear的元素，假如clear起作用，并且在垂直方向上将这个元素向下推离了。那么被移动的这50px就是clearance，如果后一个元素自带60px的上外边距，那么即使设置了clear，也不会产生推移，也就没有clearance）。 相邻也意味着多种情况，只要处于同一个BFC当中，父元素的上外边距就会和第一个子元素的上外边距重叠。如果父元素其height为auto其下外边距也会最后一个子元素的下外边距重叠。对于min-height计算值为0的情况，比如说一个没有内容没有高度没有边框没有padding的div，其自身的上下边距也会也会重叠，这也就是自身的上下边距相邻。同时在这种情况下，如果这个0高元素上没有clearance，他还可以后续元素的外边距甚至是父元素的下外边距重叠。 但是如果有clearance，则不会与父元素的下外边距重叠。这个有clearance的特例情况在IE和FireFox下有，Chrome下只要有clear，不管有没有推出clearance都不会和父元素的下外边距重叠。 上面说明白了是处于同一个BFC中才发生外边距折叠。而在一个元素上触发BFC，是为该元素的子元素新建了一个BFC，而这个元素并没有被包含在这个新BFC中，因此两个相邻的发生边距折叠的兄弟元素，分别在他们身上触发BFC并不会取消边距折叠。 不发生外边距折叠的情况：浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠。 这里看起来跟会触发BFC的情况很相似，但是其实还是差距很大的，所以一定要区分BFC和边距重叠。最好单独记忆不发生外边距重叠的情况。 CSS定位方案css布局宏观上来说是受定位方案影响，定位方案包括普通流，浮动，定位 普通流元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述只要不是float和绝对定位方式布局的，都在普通流里面。浮动 浮动框不在文档的普通流中，浮动的流会漂浮在普通的流上面。浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 定位 相对定位在普通流之中，是相对于它在普通流中的位置中进行移动，元素占据原来位置 绝对定位脱离普通流，不占据空间相对于距离它最近的那个已定位的祖先(相对/绝对)元素决定的。 固定定位，相对于浏览器窗口定位，脱离普通流，不占据空间","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"BFC","slug":"BFC","permalink":"http://yoursite.com/tags/BFC/"}]},{"title":"js设计模式(二)","date":"2017-04-05T09:09:12.000Z","path":"2017/04/05/设计模式（二）/","text":"包括代理模式，迭代器模式以及观察者模式 代理模式单例模式的关键是当客户不方便直接访问一个对象或者不满足需要的时候，提供一个对象来控制对这个对象访问，客户实际访问的是替身对象。替身对象对请求作出一些处理后再把请求转给本体对象 现在我们假定一个场景，女神A在心情好的时候收到花，小明表白成功的几率有60%，而A心情不好时几率几乎为0.但小明不知道A什么时候心情好，可是女神A的闺蜜B知道啊，所以小明打算先把花给B，等到A心情好时再转交，这样成功几率杠杠的。12345678910111213141516171819202122232425var Flower = function()&#123;&#125;;var xiaoming = &#123; sendFlower:function(target)&#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;;var B = &#123; receiveFlower: function(flower)&#123; A.listenGoodMood(function()&#123; A.receiveFlower(flower); &#125;); &#125;&#125;;var A = &#123; receiveFlower: function(flower)&#123; console.log('收到花' + flower); &#125;, listenGoodMood: function(fn)&#123; setTimeout(function()&#123; fn(); &#125;,1000); &#125;&#125;;xiaoming.sendFlower(B); 上面是一个简单的代理模式例子，接下来说一下在JavaScript开发中常见的虚拟代理和缓存代理； 虚拟代理把一些开销大的对象延迟到真正需要的时候再创建1.可用在合并HTTP请求，如收集规定时间段内想要发起得到HTTP请求，然后再一次性发起请求2.用在惰性加载中 可以用虚拟代理实现图片预加载12345678910111213141516171819202122var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src)&#123; imgNode.src = src; &#125; &#125;;&#125;)();var proxyImage = (function()&#123; var img = new Image; img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src)&#123; myImage.setSrc('proxy_url'); img.src = src; &#125; &#125;; &#125;)();proxyImage.setSrc('url'); 通过proxyImage间接访问myImage，在此过程中，添加操作，例子中是当url图片加载完成之前，使用一个本地的菊花图代替； 但是一定需要用虚拟代理模式吗？先看一下不用代理模式的图片预加载函数1234567891011121314var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src)&#123; myImage.setSrc('url'); img.src = src; &#125; &#125;;&#125;)();myImage.setSrc('url'); 至于为什么推荐用代理模式呢，那么就得说说面向对象设计的原则————单一职责原则单一职责原则指的是，就一个类(也包括对象和函数等)而言，应该仅有一个引起它变化的原因。如果一个对象承担了很多职责，就意味着对象会变得庞大，引起它变化的原因可能有多个。面向对象设计鼓励将行为分布到细粒度的对象中，如果一个对象承担的职责过多，相当于把职责耦合在一起，这会导致脆弱和低内聚的设计。当变化发生时，设计可能遭到意外破坏 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递的参数跟之前的一致，那么可以直接返回前面的结果，也可用在ajax异步请求数据; 如计算乘积12345678910111213141516171819202122var mult = function()&#123; console.log('开始计算'); var a =var mult = function()&#123; console.log('开始计算'); var a = 1; for ( var i = 0,l = arguments.length;i &lt; l;i++)&#123; a = a*arguments[i]; &#125; return a;&#125;;var proxyMult = (function()&#123; var cache = []; return function()&#123; var args = Array.prototype.join.call(arguments, ','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = mult.apply(this,arguments);; &#125;;&#125;)();proxyMult(1,2,3,4);proxyMult(1,2,3,4); 迭代器模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。现在大多数都内置了迭代器实现，，如Array.prototype.forEach 下面用内部迭代器实现的一个简单迭代器，比较两个数组的元素:1234567891011121314151617var each = function(ary,callback)&#123; for (var i = 0,l = ary.length; i &lt; l; i++) &#123; callback.call(ary[i],i,ary[i]); &#125;&#125;;var compare = function(ary1,ary2)&#123; if(ary1.length !== ary2.length)&#123; console.log('不相等')； &#125; each(ary1,function(i,n)&#123; if(n !== ary2[i])&#123; console.log(\"不相等\"); &#125; &#125;)； console.log(\"相等\");&#125;compare([1,2,3],[1,2,4]); 这是利用js中能把函数当成参数传递的特性才完成的，但在其他语言是行不通的。那么来看另一种实现方法 外部迭代器必须显式地请求迭代下一个元素，虽然增加了调用的复杂度，但增加了灵活性123456789101112131415161718192021222324252627282930var Iter = function(obj)&#123; var current = 0; var next = function()&#123; current +=1; &#125;; var isDone = function()&#123; return current &gt;= obj.length; &#125;; var getCurrTtem = function()&#123; return obj[current]; &#125;; return &#123; next: next, isDone: isDone, getCurrTtem: getCurrTtem &#125;;&#125;;var compare = function(iter1,iter2)&#123; while(!iter1.isDone()&amp;&amp;!iter2.isDone())&#123; if(iter1.getCurrTtem()!==iter2.getCurrTtem())&#123; console.log(\"不相等\"); &#125; iter1.next(); iter2.next(); &#125; console.log(\"相等\");&#125;;var iter1 = Iter([1,2,3]);var iter2 = Iter([1,2,4]);compare(iter1,iter2); 发布-订阅者模式(观察者模式)定义对象间的一种一对一的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知，js中用事件模型替代传统的发布-订阅模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var Event = (function()&#123; var clientList = &#123;&#125;, listen, trigger, remove; // 监听消息 listen = function(key,fn)&#123; if(!clientList[key])&#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; //发布消息 trigger = function()&#123; var key = Array.prototype.shift.call(arguments),fns = clientList[key]; if(!fns || fns.length === 0 )&#123; return false; &#125; for (var i = 0,fn ;fn = fns[i++];)&#123; fn.apply(this,arguments); &#125; &#125;; //取消订阅 remove = function(key,fn)&#123; var fns = clientList[ key ]; if(!fns)&#123; return false; &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0); &#125;else&#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[ l ]; if(_fn === fn)&#123; fns.splice(l,1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;;&#125;)();Event.listen('s88',function(price)&#123; console.log('价格='+price);&#125;);Event.listen('s100',function(price)&#123; console.log('价格='+price);&#125;);Event.trigger('s88',100);Event.trigger('s100',200); 这是一个用全局的Event对象来实现的订阅-发布模式，订阅者不需要知道消息来着哪个发布者，发布者也不需要消息会推送给谁，就类似于一个全托的房屋中介。","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"js设计模式(一)","date":"2017-04-01T09:09:12.000Z","path":"2017/04/01/设计模式（一）/","text":"包括单例模式，策略模式 1.单例模式单例模式的核心是确保只有一个实例，并提供全局访问在js中，全局变量也符合这两个条件，就是说可以当成单例使用如var a = {},但是它很容易造成命名空间污染，随时有可能被覆盖，我们应尽量减少全局变量的使用方法有：1.使用命名空间2.使用闭包封装私有变量 通用的惰性单例 例子：新建一个登录div 1234567891011121314151617181920212223//业务逻辑（创建对象）var createLoginLayer = function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;//创建单例var getSingle = function( fn )&#123; var result; return function()&#123; return result||( result = fn.apply(this, arguments) ); &#125;;&#125;;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginbtn').onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;; 单例模式是比较简单却很实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。奇妙的是，创建对象和管理单例的职责分布在两个方法中，两个方法组合才具有单例模式的威力。 2.策略模式定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换 例子：元素（小球）页面中运动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//运动算法var tween =&#123; linear:function(t,b,c,d)&#123; return c*t/d + b; &#125;, easeIn:function(t,b,c,d)&#123; return c*(t/=d)*t+b; &#125;, strongEaseIn:function(t,b,c,d)&#123; return c*(t/=d)*t*t*t*t +b; &#125;, strongEaseOut:function(t,b,c,d)&#123; return c*((t=t/d-1)*t*t*t*t+1) +b; &#125;, sineasIn:function(t,b,c,d)&#123; return c*(t/=d)*t*t +b; &#125;, sineasOut:function(t,b,c,d)&#123; return c*((t=t/d-1)*t*t+1) +b; &#125;,&#125;;//运动的元素节点var Animate = function(dom)&#123; this.dom = dom; this.startTime = 0; this.startPos = 0; this.endPos = 0; this.propertyName = null; this.easing = null; this.duration = null;&#125;;// 启动/停止动画，记录信息Animate.prototype.start = function(propertyName,endPos,duration,easing)&#123; this.startTime = +new Date; //启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; //初始位置 this.propertyName = propertyName; //改变的CSS属性 this.endPos = endPos; //目标位置 this.duration = duration; //持续时间 this.easing = tween[easing]; //运动算法 var self =this; var timeId = setInterval(function()&#123; if(self.step() === false)&#123; clearInterval(timeId); &#125; &#125;,19);&#125;;//每一帧做的操作Animate.prototype.step = function()&#123; var t =+new Date; if (t &gt;= this.startTime+this.duration) &#123; this.update(this.endPos); //更新位置 return false; &#125; var pos = this.easing(t-this.startTime,this.startPos,this.endPos-this.startPos,this.duration); //运动算法 this.update(pos);&#125;;Animate.prototype.update = function(pos)&#123; this.dom.style[this.propertyName] = pos +'px';&#125;;var div = document.getElementById('div');var animate = new Animate(div);animate.start('left',500,1000,'strongEaseOut'); 策略模式是一种常见且有效的设计模式，他的优点有： 利用组合，委托和多态等技术思想，有效避免多重条件选择语句 提供对开放-封闭原则的支持，将算法封装在独立的strategy中，方便切换 算法可以复用在系统的其他地方，避免重复复制 利用组合和委托让context拥有执行算法的能力，这是继承的一种替代方案缺点：程序会增加许多策略类或对象；必须了解各个strategy之间的不同点，才能选择合适的strategy；","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"常见js算法汇总(三)","date":"2017-03-30T12:09:12.000Z","path":"2017/03/30/常见算法汇总（三）/","text":"基数排序，计数排序，桶排序 基数排序基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； 12345678910111213141516171819202122232425262728293031323334353637/** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数*///LSD Radix Sortfunction radixSort(arr,maxDigit)&#123; varmod=10; vardev=1; varcounter=[]; console.time('基数排序耗时'); for(vari=0;i&lt;maxDigit;i++,dev*=10,mod*=10)&#123; for(varj=0;j&lt;arr.length;j++)&#123; varbucket=parseInt((arr[j]%mod)/dev); if(counter[bucket]==null)&#123; counter[bucket]=[]; &#125; counter[bucket].push(arr[j]); &#125; varpos=0; for(varj=0;j&lt;counter.length;j++)&#123; varvalue=null; if(counter[j]!=null)&#123; while((value=counter[j].shift())!=null)&#123; arr[pos++]=value; &#125; &#125; &#125; &#125; console.timeEnd('基数排序耗时'); returnarr;&#125;vararr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(radixSort(arr,2));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 计数排序最佳情况：T(n) = O(n+k)最差情况：T(n) = O(n+k)平均情况：T(n) = O(n+k) . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 1234567891011121314151617181920212223function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd('计数排序耗时'); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 7, 2, 1, 4, 2, 4, 7, 2, 5];console.log(countingSort(arr)); 桶排序最佳情况：T(n) = O(n+k)最差情况：T(n) = O(n+k)平均情况：T(n) = O(n2) .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 12345678910111213141516171819202122232425262728293031323334353637383940/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; //非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd('桶排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4)); 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶计数排序：每个桶只存储单一键值桶排序： 每个桶存储一定范围的数值","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"常见js算法汇总(二)","date":"2017-03-29T03:09:12.000Z","path":"2017/03/29/常见算法汇总（二）/","text":"接着上一篇博客,选择排序与归并排序 选择法排序选择法主要有三种： . 简单的选择排序：其实基本的思想就是从待排序的数组中选择最小或者最大的，放在起始位置，然后从剩下的数组中选择最小或者最大的排在这公司数的后面。1234567891011121314151617function selectionSort(data)&#123; var i, j, min, temp , count=data.length; for(i = 0; i &lt; count - 1; i++) &#123; // find the minimum min = i; for (j = i+1; j &lt; count; j++)&#123; if (data[j] &lt; data[min])&#123; min = j; &#125; &#125; // swap data[i] and data[min] temp = data[i]; data[i] = data[min]; data[min] = temp; &#125; return data;&#125; 树型排序：又称锦标赛排序，首先对n个元素进行两两比较，然后在其中[n/2]个较小者再进行两两比较如此重复直至选出最小的关键字的纪录为止。（可用完全二差树表示）。缺点：辅助空间需求过大，和“最大值”进行多余比较12 堆排序：（不适用于纪录数较少的文件） 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(nlogn)平均情况：T(n) = O(nlogn) .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd('堆排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number')&#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 归并排序所谓归并就是将两个或者两个以上的有序表合成一个新的有序表。递归形式的算法在形式上较为简洁但实用性较差，与快速排序和堆排序相比，归并排序的最大特点是，它是一种稳定的排序方法。 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 12345678910111213141516171819202122232425262728293031323334function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length)&#123; result.push(left.shift()); &#125; while (right.length)&#123; result.push(right.shift()); &#125; console.timeEnd('归并排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); 将有二个有序数列a[first…mid]和a[mid…last]合并。123456789101112131415161718192021222324252627282930313233function mergearray(Arr,first,mid,last,tempArr)&#123; var i = first, j = mid + 1; var m = mid, n = last; var k = 0; while (i &lt;= m &amp;&amp; j &lt;= n)&#123; if (Arr[i] &lt; Arr[j])&#123; tempArr[k++] = Arr[i++]; &#125;else&#123; tempArr[k++] = Arr[j++]; &#125; while (i &lt;= m)&#123; tempArr[k++] = Arr[i++]; &#125; while (j &lt;= n)&#123; tempArr[k++] = Arr[j++]; &#125; for (i = 0; i &lt; k; i++)&#123; Arr[first + i] = tempArr[i]; &#125;&#125;function mergesort(Arr,first,last)&#123; var tempArr=new Array(); if (first &lt; last)&#123; var mid = (first + last)&gt;&gt;&gt;1; mergesort(Arr, first, mid, tempArr); //左边有序 mergesort(Arr, mid + 1, last, tempArr); //右边有序 mergearray(Arr, first, mid, last, tempArr); //再将二个有序数列合并 &#125; return Arr;&#125;var Arr=new Array(1,65,45,98,56,78);alert(mergesort(Arr,0,Arr.length-1));","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"常见算法汇总(一)","date":"2017-03-28T07:19:35.000Z","path":"2017/03/28/常见算法汇总（一）/","text":"写这篇文章是因为之前学了一些常见算法，并随手记录了下来，然而当时并没有博客，这不，有了博客马上放上来了，有去重，二分法，冒泡，插入1. 数组去重1234567891011121314151617function delRepeat(arr)&#123; var newArray=new Array(); var len=arr.length; for(var i=0;i&lt;len;i++)&#123; for(var j=i+1;j&lt;len;j++) &#123; if(arr[i]==arr[j]) &#123; ++i; &#125; &#125; newArray.push(arr[i]); &#125; return newArray;&#125;var arr=new Array(\"red\",\"red\",\"1\",\"5\",\"2\");alert(delRepeat(arr)); 2.求字符串长度的方法 12345678910function GetBytes(str)&#123; var len=str.length, bytes=len; for(var i=0;i&lt;len;i++)&#123; if(str.CharCodeAt&gt;255)&#123; bytes++; &#125; &#125; return bytes;&#125; 3.二分法 又称为折半查找算法，但是有缺陷就是要求数字是预先排序好的 1234567891011121314function binary(items,value)&#123; var startIndex=0, stopIndex=items.length-1, midlleIndex=(startIndex+stopIndex)&gt;&gt;&gt;1; while(items[middleIndex]!=value &amp;&amp; startIndex&lt;stopIndex)&#123; if(items[middleIndex]&gt;value)&#123; stopIndex=middleIndex-1; &#125;else&#123; startIndex=middleIndex+1; &#125; middleIndex=(startIndex+stopIndex)&gt;&gt;&gt;1; &#125; return items[middleIndex]!=value ? false:true;&#125; 4.实现递归 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125; 但是这在js里面可能会出现错误，如： 123var anotherFactorial = factorial;factorial=null;alert(anoterFactorial(4)); 因为在调用anoterFactorial时内部的factorial已经不存在了。解决方法是通过arguments.callee来解决。如下： 12345678910function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125; var anotherFactorial = factorial; factorial = null; alert(anotherFactorial(4));//成功！！！&#125; 5.冒泡排序 12345678910111213function bullSort(array)&#123; var temp; for(var i=0;i&lt;array.length;i++)&#123; for(var j=array.length-1;j&gt;i;j--)&#123; if(array[j]&lt;array[j-1])&#123; temp = array[j]; array[j]=array[j-1]; array[j-1]=temp; &#125; &#125; &#125; return array;&#125; 6.快速排序 其实说到底快速排序算法就系对冒泡排序的一种改进，采用的就是算法理论中的分治递归的思想,做法就是：通过一趟排序将待排序的纪录分割成两部分，其中一部分的纪录值比另外一部分的纪录值要小，就可以继续分别对这两部分纪录进行排序；不段的递归实施上面两个操作，从而实现纪录值的排序。 12345678910111213141516171819202122232425function sort(arr)&#123; return quickSort(arr,0,arr.length-1); function quickSort(arr,l,r)&#123; if(l&lt;r)&#123; var mid=arr[parseInt((l+r)/2)],i=l-1,j=r+1; while(true)&#123; //大的放到右边，小的放到左边, i与j均为游标 while(arr[++i]&lt;mid); while(arr[--j]&gt;mid); if(i&gt;=j)break;//判断条件 var temp = arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; quickSort(arr,l,i-1); quickSort(arr,j+1,r); &#125; return arr; &#125;&#125;function main()&#123; var list=new Array(49,38,65,97,76,13,27); document.write(sort(list).valueOf());&#125;main(); 7.插入排序 即将序列中的第一个元素看成一个有序的子序列，然后不段向后比较交换比较交换。 1234567891011121314function insertSort(arr)&#123; var key; for(var j = 1; j &lt; arr.length ; j++)&#123; //排好序的 var i = j - 1; key = arr[j]; while(i &gt;= 0 &amp;&amp; arr[i] &gt; key)&#123; arr[i + 1] = arr[i]; i --; &#125; arr[i + 1] = key; &#125; return arr;&#125; 8.希尔排序 也称递减增量排序算法 1234567891011121314151617181920212223242526272829303132333435363738function shellSort(array)&#123; var stepArr = [1750, 701, 301, 132, 57, 23, 10, 4, 1]; // reverse()在维基上看到这个最优的步长较小数组 var i = 0; var stepArrLength = stepArr.length; var len = array.length; var len2 = parseInt(len/2); for(;i &lt; stepArrLength; i++)&#123; if(stepArr[i] &gt; len2)&#123; continue; &#125; stepSort(stepArr[i]); &#125; // 排序一个步长 function stepSort(step)&#123; //console.log(step) 使用的步长统计 var i = 0, j = 0, f, tem, key; var stepLen = len%step &gt; 0 ? parseInt(len/step) + 1 : len/step; for(;i &lt; step; i++)&#123; // 依次循环列 for(j=1;/*j &lt; stepLen &amp;&amp; */step * j + i &lt; len; j++)&#123; //依次循环每列的每行 tem = f = step * j + i; key = array[f]; while((tem-=step) &gt;= 0)&#123; // 依次向上查找 if(array[tem] &gt; key)&#123; array[tem+step] = array[tem]; &#125;else&#123; break; &#125; &#125; array[tem + step ] = key; &#125; &#125; &#125; return array;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"前端知识大乱炖（转）","date":"2017-03-28T01:09:12.000Z","path":"2017/03/28/前端打乱炖（转）/","text":"声明：放到博客里是为了方便自己阅读，主要是入门以及提高的方法，参考书籍来源: https://github.com/qiu-deqing/FE-learning FE-learning 必备基础技能 基本开发工具 学习方法和学习目标 入门之路 继续提高 一些个人经历 LingyuCoder的学习经历 工具 技能 语言基础 进阶 项目 未来 其他 入门书 一些不错的网站 历程 MrRaindrop的学习经历 缘起 项目，下一个项目 收集癖和知识管理 跟对神 读书 前端的定位 最后 byr论坛yiyizym的建议 必备基础技能前端技能汇总这个项目详细记录了前端工程师牵涉到的各方面知识。在具备基本技能之后可以在里面找到学习的方向，完善技能和知识面。 frontend-dev-bookmarks是老外总结的前端开发资源。覆盖面非常广。包括各种知识点、工具、技术，非常全面。 以下是个人觉得入门阶段应该熟练掌握的基础技能： HTML4，HTML5语法、标签、语义 CSS2.1，CSS3规范，与HTML结合实现各种布局、效果 Ecma-262定义的javascript的语言核心，原生客户端javascript，DOM操作，HTML5新增功能 一个成熟的客户端javascript库，推荐jquery 一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟， HTTP 在掌握以上基础技能之后，工作中遇到需要的技术也能快速学习。 基本开发工具恰当的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并解决问题，以下是个人觉得必备的前端开发工具： 文本编辑器：推荐Sublime Text，支持各种插件、主题、设置，使用方便 浏览器：推荐Google Chrome，更新快，对前端各种标准提供了非常好的支持 调试工具：推荐Chrome自带的Chrome develop tools，可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等 辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools， 翻墙工具：lantern, 壁虎漫步（已被和谐） 学习方法和学习目标方法： 入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果 在具备一定基础之后可以上网搜各种教程、demo，了解各种功能的实际用法和常见功能的实现方法 阅读HTML，CSS，Javascript标准全面完善知识点 阅读前端牛人的博客、文章提升对知识的理解 善用搜索引擎 目标： 熟记前面知识点部分的重要概念，结合学习经历得到自己的理解 熟悉常见功能的实现方法，如常见CSS布局，Tab控件等。 入门之路以下是入门阶段不错的书籍和资料 HTML先看《HTML &amp; CSS: Design and Build Websites》1-9章，然后《HTML5: The Missing Manual》1-4章。 CSS先看《CSS: The Missing Manual》，然后《CSS权威指南》 javascript先看《javascript高级程序设计》，然后《javascript权威指南》 HTTP看HTTP权威指南 在整个学习过程中HTML CSS JavaScript会有很多地方需要互相结合，实际工作中也是这样，一个简单的功能模块都需要三者结合才能实现。 动手是学习的重要组成部分，书籍重点讲解知识点，例子可能不是很充足，这就需要利用搜索引擎寻找一些简单教程，照着教程实现功能。以下是一些比较好的教程网址 可以搜索各大公司前端校招笔试面试题作为练习题或者他人总结的前端面试题还有个人总结的面试题（带参考答案） http://code.tutsplus.com有各种各样的教程 MDN也有很多教程，更重要的是里面有详细的文档，需要查找某个功能时在Google搜索：xxx site:https://developer.mozilla.org http://www.html5rocks.com/zh/也有很多优质教程 http://www.sitepoint.com/ http://alistapart.com/ 原生javascript是需要重点掌握的技能，在掌握原生javascript的基础上推荐熟练掌握jQuery，在实际工作中用处很大，这方面的书籍有《Learning jQuery》或者去jQuery官网 建一个https://github.com/账号，保存平时学习中的各种代码和项目。 有了一定基础之后可以搭建一个个人博客，记录学习过程中遇到的问题和解决方法，方便自己查阅也为其他人提供了帮助。也可以去http://www.cnblogs.com/或者http://www.csdn.net/这样的网站注册账号，方便实用 经常实用Google搜索英文资料应该经常找到来自http://stackoverflow.com/的高质量答案，遇到问题可以直接在这里搜索，如果有精力，注册一个账号为别人解答问题也能极大提高个人能力。 经典书籍熟读之后，可以打开前面必备基础技能部分的链接。认真读对应标准，全面掌握知识 继续提高有了前面的基础之后，前端基本算是入门了，这时候可能每个人心中都有了一些学习方向，如果还是没有。可以参考前面必备技能部分提到的那两个项目，从里面选一些进行发展学习。以下是一些不错的方面： Grunt：前端自动化工具，提高工作效率 less css：优秀的CSS预处理器 bootstrap：优秀的CSS框架，对没有设计师的团队很不错，与less结合使用效果完美 requirejs：AMD规范的模块加载器，前端模块化趋势的必备工具 Node.js：JavaScript也可以做后台，前端工程师地位更上一步 AngularJS：做Single Page Application的好工具 移动端web开发：智能手机的普及让移动端的流量正在逐步赶超PC端 Javascript内存管理：SPA长期运行需要注意内存泄露的问题 High Performance JavaScript(Build Faster Web Application Interfaces) Best Practices for Speeding Up Your Web Site：重要技能 一些个人经历LingyuCoder的学习经历上面的大神都总结得差不多了，我这里就胡扯一些吧 ####工具 chrome dev tools：前端开发调试利器，着重注意几个功能： console（废话） elements:元素样式调整，很常用 sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象 watch expression：通过表达式查看当前内存中的值 call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候） scope variables：作用域链上的变量，非常有用 network：抓包查看每个请求，非常重要，前后端联调必备 timeline：分析渲染、js执行等等各个阶段，性能优化利器 emulation：模拟移动端环境，mobile页面开发必备 一些插件: liveload: 修改页面后自动刷新，不用按F5 dimensions：直接在页面上测量的利器 livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中 image tool：测量，取色 UC二维码：移动端调试扫码必备 pagespeed，YSlow：页面性能分析和优化插件 马克飞象：优秀的在线markdown编辑器，快速写周报，做记录 sublime text3：编码方便，插件多，速度快，性能好 emmet：提升html编码速度必备 sublimelinter + 各种语言的lint和hint：代码纠错 一些snippets：自动补全，提升开发效率 Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能 Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件 GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子 iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备 Charles：Mac 平台最好用的抓包分析工具 Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用 Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便 ####技能前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说 #####语言基础JavaScript： 作用域链、闭包、运行时上下文、this 原型链、继承 NodeJS基础和常用API CSS： 选择器 浏览器兼容性及常见的hack处理 CSS布局的方式和原理（盒子模型、BFC、IFC等等） CSS 3，如animation、gradient、等等 HTML： 语义化标签 #####进阶JavaScript: 异步控制（Promise、ES6 generator、Async） 模块化的开发方式（AMD、CMD、KMD等等） JavaScript解释器的一些相关知识 异步IO实现 垃圾回收 事件队列 常用框架使用及其原理 jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研 AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦 underscore：优秀的工具库，方便的理解常用工具代码片段的实现 polymer/React: 组件化开发，面向未来，理解组件化开发的原理 CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理 DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程 解析HTML、CSS、JavaScript时造成的阻塞 HTML5相关 SVG及矢量图原理 Canvas开发及动画原理（帧动画） Video和Audio flex box布局方式 icon fonts的使用 常用NodeJs的package： koa express underscore async gulp grunt connect request 一些理念： 响应式Web 优雅降级、渐进增强 don’t make me think 网页可用性、可访问性、其中的意义 SEO搜索引擎优化，了解搜索引擎的原理 SPA的好处和问题 性能优化： 减少请求数量（sprite、combo） 善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式） 减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离） CSS的回流与重绘 #####项目 版本管理：首推Git，用过Git都不会想用SVN了 Git：本地版本管理的机制 SVN：远程中心的版本管理机制 自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并 Gulp：基于流构建，速度快、模块质量好 Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高 预处理和模板引擎 less：语法简单，但功能有限 jade、ejs、velocity等模板引擎，各有各的长处 coffee：python工程师最爱，我没用过 环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了 本地代理：ihosts 自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果 jasmine mocha 生态系统 npm bower spm 搭建一个属于自己的博客 git pages hexo jekyll #####未来 Web Componets：面向未来的组件化开发方式 HTML模板 Shadow DOM Custom Elements HTML Import 移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发 #####其他有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方 对于业务的思考：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务 交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目 知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录 对新技术的渴望，以及敢于尝试 ####入门书入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书： 《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看 《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助 《编写可维护的JavaScript》 《JavaScript DOM编程艺术》学习JavaScript和DOM开发的必读之作。 《Node.js开发指南》：不错的Nodejs入门书籍 《深入浅出Node.js》：Nodejs进阶书籍，必备 《JavaScript异步编程》：理解JS异步的编程理念 《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书 《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西 《Don`t make me think》：网页设计的理念，了解用户行为，非常不错 《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题 《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习 《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助 《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识 《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想 《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门 ####一些不错的网站 github：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习 codepen：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件 echojs：快速了解js新资讯的网站 stackoverflow和segmentfault：基本上各种问题都能在上面获得解答 google web fundamentals：每篇文章都适合仔细阅读 static files：开放的CDN，很好用 iconfont：阿里的矢量图标库，非常不错，支持CDN而且支持项目 html5 rocks: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章 css tricks：如何活用CSS，以及了解CSS新特性，这里可以满足你 JavaScript 秘密花园 JavaScript初学必看，非常不错 w3cplus：一个前端学习的网站，里面的文章质量都挺不错的 node school：一个不错的node学习网站 learn git branch：一个git学习网站，交互很棒 前端乱炖：一个前端文章分享的社区，有很多优秀文章 正则表达式：一个正则表达式入门教程，非常值得一看 阮一峰的博客和张鑫旭的博客：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源 各路大牛的博客：这个太多了，就不贴了，知乎上有很全的 各种规范的官方网站，不懂得时候读规范 ####历程以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和W3C School上的教程，以及一些前端博客，如汤姆大叔的博客。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了… MrRaindrop的学习经历应qiu神的邀请分享一下前端学习经验，这里对前端知识体系架构就不做总结了，各位大神们的总结已经相当到位了，我就贡献几个个人认为还比较有用的链接大家研究研究就好，然后主要分享一下我在前端学习过程中遇到的问题和总结的经验教训吧，如果能帮到想要入门的FE初学者（我就姑且假定为本文的读者受众类型了），让他们少走点弯路，每走一步都知道自己下一步的方向，这是最好了。各位大神的总结和分享详见qiu神整理的FE-learning。 先说下，前端这个东西每个人都可以有适合自己的学习方法，这篇仅作参考，写的有点乱，各位凑合看。 缘起我是属于误打误撞进了前端，之前一直往做游戏的方向去来着，搞过游戏网站，玩过游戏引擎，比如unity，unreal这种商业引擎，捣鼓了几个游戏原型，不过自打研一进了实验室，直接就被导师派去写了js，导师给了我半个月时间让我写个基于百度地图api的数据展示页面，虽然这个时间还是相当宽裕的，不过之前没怎么写过js，也不会用地图api，于是我就一边啃着《Javascript权威指南》（犀牛书）一边参考实验室前人留下的“代码”，总算是把功能都写出来了。那个页面算我的js入门作了，也是我前端学习路线的开始。 现在想来，虽然指派了去做前端，但是一直做下去并做好还是得靠兴趣维持，当然前端是一个趣味性十足的技术领域，而且社区每天都很“热闹”。 项目，下一个项目我个人认为前端的学习，初学阶段你可以完全脱离开书本，以项目驱动。虽然我个人是从犀牛书开始啃的，不过如果你没有充足的时间，或者觉得啃大部头乏而无味的话，还是别像我这样。当然了如果决定啃书最好是把书里的例子都跟着敲一遍的。我上研之前没接触过js，4月份还没开学呢就被直接被导师甩了个百度地图api的项目到脸上，接着就是各种ERP，地图数据展示，虽然换着花样来一点不重样，不过基本上都是前端的活，SSH和android开发也打过酱油，整个实验室就我一个人写前端敢信？富客户端SPA时代的后端就是一个restful接口，代码量基本都在前端啊，写的我一个人怎一个爽字了得…期间跟着导师感受了一把创业，每天从7点搞到晚上10点，也算是经历了一段快速成长期。 掌握一门技术先掌握它的大体框架，想一个能实现的点子，做一个能跑就行的demo，再去完善它的细节，等到demo完成了，对这门技术有了一个感性的认识，再去啃书，收获会大很多。我从开始原生js写到jquery，再到extjs，再到angularjs，从导师指定技术，到自己做技术选型，一个项目接着一个项目的练，就跟打怪升级似的。当然没有项目就去自己创造项目，动手实现自己的想法是件有乐趣和成就感的事。 收集癖和知识管理前端学习有个特点，很多东西都很零碎，分散，需要你自己去整理、归纳和总结。在微博、知乎上follow了众多的大神，你不仅仅是为了听八卦，大神们的只言片语有时候留下的是无尽的余味，很有可能一个不经意提到的一个词就成为你下一个学习的目标。收集这些信息，善用google，提问，思考。就像游戏里的收集要素，前端学习也是充满搜集要素的一个“游戏”，只不过你需要一个知识管理工具来充当物品栏和仓库，我所知道的大牛们无一不是知识管理工具的重度使用者。以前用的oneNote，那时候还没绑定到云存储，现在基本上用evernote，笔记已经累计到1200+篇。书签一直打算用delicious，因为它是基于tag管理的，但一直没用起来。当然重点不在于这些工具，但是趁手的工具可以提高你的学习效率。最关键当然是随时保持旺盛的学习欲望，你的目标是了解有关前端的一切（当然不是所有都要掌握，因为毕竟你的精力有限，而且现实的说这也不太可能）。 跟对神这个可控性貌似不大…跟对老大这个就不多说了，一定程度要看造化。不过话说回来，多跟身边的高手交流是王道，这个高手不一定要多高，但是一定要对技术有热情。研一的时候热情高涨，每天7点进实验室门，然后发现有个家伙居然比我还早到。后来发现这家伙上午就走了，下午又来了，而且导师对此习以为常，原来这家伙晚上不睡觉通宵写代码，上午才跑回去睡。后来经常和这位神讨论问题，每次感觉经验值蹭蹭蹭的往上涨。然后实验室还有一位神，被前面这位通宵神形容为“只能望其项背，一直在追赶，从来没赶上”，两位神的特点都是什么都了解一点，所以什么都能跟你讨论得起来，我有段时间做了个读书计划，从c/c++到vc/mfc再到unix网络编程，最后一路看到java核心技术和MSDN上的C#编程指南，和神们也能扯得很high了。 总之就是这两位神把我拉进了坑，或者说从一个坑跳进另一坑，虽然两位神都不是搞前端的，不过技术之间总有相通之处。 读书读书，多读书，读好书。在刘未鹏的博客里看到过一个公式，你第一个月的工资等于之前买过（读过）的技术书价格总和（这里说的技术书指那些经典的公认的好书）。讨论这个公式的正确性似乎没什么意义，然而它的合理性是毋庸置疑的，那就是多读经典技术书。最极端的一个例子，google的徐宥在我的大学里面说他扫荡了图书馆的整个TP312书架…对于前端的经典书籍，后面列了一个我收集的前端书列（如果有遗漏的前端经典好书，还请留言告诉我），有条件可以尝试刷一遍这些书，我也是在找完整的时间去啃完它们。之前说的，前端知识点松散，收集零散的知识点，从博客里快速学习等，这些只是前端学习的一个方面，如果你要想深入理解一个知识体系，了解它的来龙去脉，对它建立系统认识，读经典书还是必不可少的。 我从最开始啃完犀牛书，然后接着去看了其他一些和前端干系不大的经典技术书，再后来通过实验室的项目和自己弄的一些小项目逐渐对前端领域比较上路以后，又看了《Javascript模式》、《Javascript设计模式》、《编写可维护的Javascript》，后来了解到node并开始用node搞点小玩意儿，又看了本《NodeJS up and run》和《Mongodb权威指南》，不过感觉前者略坑。那会儿朴灵那本深入浅出（晒书么么哒）还没出，后来出了就去图书馆借来看完，这么看下来感觉还不错，不过感觉看的还是偏少了，还需要继续刷（参照上面的书列）。 前端的定位前端的定位关乎到你需要吸收什么样的知识和技能，决定在技术世界里你对什么需要格外敏感。如果你认为前端仅仅停留在切页面，实现交互和视觉的要求，那你对前端的认识还停留在初级阶段。阿里终面的时候我问了考官这么个问题：前端技术日新月异，范围越扩越宽，标准越来越丰富，似乎任何一个触角都能伸出很远。怎么给前端一个合适的定位？考官给我分析了半天，然后总结成一句话，就是用户和网站的联结者，用户体验的创造者（原话不是这样，但大体是这个意思）。也就是说前端的终极目标其实就是创造用户体验，提升用户体验，以用户体验为中心。不管你是从交互设计上下手，还是从性能优化出发，或者改进工作流提升工作流效率，最终都是为了创造和提升用户体验，最终都要体现到用户体验这一点上来。我认为这个总结非常有道理（当然“用户体验”这个词太宽泛了，并且不仅仅是前端工程师的范畴，比如开发后台的时候对一个数据处理过程进行优化，提升了整体性能，这也是对用户体验的一个提升）。 现在的前端工程师做到一定阶段不可避免会接触到很多比切页面、实现视觉要求、实现交互等更深入的问题，比如前端自动化、图像编程、性能优化等等，再往后推一点就是PHP/JSP/ASP/nodeJs，过去后端模板一般属于后端的范畴，现在随着前端架构的演进，可能会让你去写后端模板的代码，需要用到后端语言（PHP/Java/C#等），这就是所谓大前端（然而这与前端的定位并不是相背离的，大前端处理的依然是与用户接触的部分，仍然是对用户体验的优化）。可能最常见或者被谈论最多的就是node，其实这几种技术选型都可以，bat三家据说百度用PHP比较多，阿里用node比较多。 玉伯在他的博客里提过所谓全端是横向的，全栈是纵向的。全端即所有的终端说白了都是前端，因为都关乎到用户体验，直接和用户接触。适应多终端的开发，要求你在web前端的基础上，可能还要去扩展android开发和ios开发的知识，好在由于hybrid开发方式的流行，对使用native语言开发的技能会要求的不那么深入。 全栈可以说是最适合初创公司的一种发展类型，广义上认为是从前端干到后端，从开发干到运维，这种就不说了，一般人应该不会想要去往这个方向发展，想要成为这种意义上的full-stack dev的，可能用不着来看我这篇文章了；而狭义上的全栈特指使用js语言从前端写到架设在nodeJs上的后端，前后端统一语言，统一编程模型，甚至公用同一套代码。更多了解全栈开发可以看看玉伯这篇说说全栈工程师。 以上是我对前端以及衍生出来的技术路线的一些浅薄理解，学习一个领域掌握它的整体上的走向和趋势还是挺重要的。另外如果想要对前端学习方向、职业成长路径有一个整体的认识，推荐看看拔赤总结的这篇前端开发十日谈。 最后贡献几个对前端学习、面试有帮助的链接： 前端面试问题合集（Front-end-Developer-Interview-Questions） 前端技能汇总（JacksonTian） 另一张前端技能汇总图 前端那点事儿（书列） byr论坛yiyizym的建议与grunt相比，学习gulp会比较简单 做SPA的话，推荐backbone.js和 backbone.marionette.js 翻墙不用折腾，花十块钱买一个月的 红杏。 把基础打扎实了再学这些都没问题。 html 没什么好说的，有空学学html5。 css 尽量看文档 ，因为很多中文资料都各执一辞，看多了反而会糊涂。 有个网站可以查找html/css标签、属性在各个浏览器中的支持情况，挺好用的。 javascript 就看 javascript高级程序设计 。不过这么厚的书看过就会忘。对javascript核心概念的讲解：对象/原型链/ 构造函数/执行上下文/作用域链/闭包/this，这里有篇不错的文章。 有闲情可以看看 ecmascript 6。阮一峰的网站有入门资料。 jquery 有很多 API,这个网站可以方便查到。有时间弄清楚jquery deferred 的用法。 多给 sublimetext 装插件，比如说检查代码错误的，新建目录文件的，整理代码的。","categories":[{"name":"指路","slug":"指路","permalink":"http://yoursite.com/categories/指路/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]}]