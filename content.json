[{"title":"数组的相关用法","date":"2017-05-14T09:05:41.000Z","path":"2017/05/14/数组的相关用法/","text":"一些数组去重，求交集并集，最大最小值等方法 第一部分数组去重，总结了一些数组去重的方法，代码如下：12345678910111213141516171819202122232425262728293031323334//去重操作,有序状态function unique(target) &#123; let result = []; loop: for (let i = 0,n = target.length;i &lt; n; i++) &#123; for (let x = i + 1;x &lt; n;x++) &#123; if (target[x] === target[i]) &#123; continue loop; &#125; &#125; result.push(target[i]); &#125; return result;&#125;//去重操作，无序状态，效率最高function unique1(target) &#123; let obj = &#123;&#125;; for (let i = 0,n = target.length; i &lt; n;i++) &#123; obj[target[i]] = true; &#125; return Object.keys(obj);&#125;//ES6写法,有序状态function unique2(target) &#123; return Array.from(new Set(target));&#125;function unique3(target) &#123; return [...new Set(target)];&#125; 第二部分数组中获取值，包括最大值，最小值，随机值。123456789101112131415161718//返回数组中的最小值，用于数字数组function min(target) &#123; return Math.min.apply(0,target);&#125;//返回数组中的最大值，用于数字数组function max(target) &#123; return Math.max.apply(0,target);&#125;//从数组中随机抽选一个元素出来function random(target) &#123; return target[Math.floor(Math.random() * target.length)];&#125; 第三部分对数组本身的操作，包括移除值，重新洗牌，扁平化和过滤不存在的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//移除数组中指定位置的元素，返回布尔表示成功与否function removeAt(target,index) &#123; return !!target.splice(index,1).length;&#125;//移除数组中第一个匹配传参的那个元素，返回布尔表示成功与否function remove(target,item) &#123; const index = target.indexOf(item); if (~index) &#123; return removeAt(target,index); &#125; return false;&#125;//对数组进行洗牌function shuffle(array) &#123; let m = array.length, t, i; // While there remain elements to shuffle… while (m) &#123; // Pick a remaining element… i = Math.floor(Math.random() * m--); // And swap it with the current element. t = array[m]; array[m] = array[i]; array[i] = t; &#125; return array;&#125;//对数组进行平坦化处理，返回一个一维的新数组function flatten (target) &#123; let result = []; target.forEach(function(item) &#123; if(Array.isArray(item)) &#123; result = result.concat(flatten(item)); &#125; else &#123; result.push(item); &#125; &#125;); return result;&#125;//过滤属性中的null和undefined,但不影响原数组function compat(target) &#123; return target.filter(function(el) &#123; return el != null; &#125;)&#125; 第四部分根据指定条件对数组进行操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//根据指定条件（如回调或对象的某个属性）进行分组，构成对象返回。function groupBy(target,val) &#123; var result = &#123;&#125;; var iterator = isFunction(val) ? val : function(obj) &#123; return obj[val]; &#125;; target.forEach(function(value,index) &#123; var key = iterator(value,index); (result[key] || (result[key] = [])).push(value); &#125;); return result;&#125;function isFunction(obj)&#123; return Object.prototype.toString.call(obj) === '[object Function]';&#125;// 例子function iterator(value) &#123; if (value &gt; 10) &#123; return 'a'; &#125; else if (value &gt; 5) &#123; return 'b'; &#125; return 'c';&#125;var target = [6,2,3,4,5,65,7,6,8,7,65,4,34,7,8];console.log(groupBy(target,iterator));//获取对象数组的每个元素的指定属性，组成数组返回function pluck(target,name) &#123; let result = [],prop; target.forEach(function(item) &#123; prop = item[name]; if (prop != null) &#123; result.push(prop); &#125; &#125;); return result;&#125;//根据指定条件进行排序，通常用于对象数组function sortBy(target,fn,scope) &#123; let array = target.map(function(item,index) &#123; return &#123; el: item, re: fn.call(scope,item,index) &#125;; &#125;).sort(function(left,right) &#123; let a = left.re, b = right.re; return a &lt; b ? -1 : a &gt; b ? 1 : 0; &#125;); return pluck(array,'el');&#125; 第五部分数组的并集，交集和差集。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//对两个数组取并集function union(target,array) &#123; return unique(target.concat(array));&#125;//ES6的并集function union1(target,array) &#123; return Array.from(new Set([...target,...array]));&#125;//对两个数组取交集function intersect(target,array) &#123; return target.filter(function(n) &#123; return ~array.indexOf(n); &#125;)&#125;//ES6 交集function intersect1(target,array) &#123; array = new Set(array); return Array.from(new Set([...target].filter(value =&gt; array.has(value))));&#125;//差集function diff(target,array) &#123; var result = target.slice(); for (var i = 0;i &lt; result.length;i++) &#123; for (var j = 0; j &lt; array.length;j++) &#123; if (result[i] === array[j]) &#123; result.splice(i,1); i--; break; &#125; &#125; &#125; return result;&#125;// ES6 差集function diff1(target,array) &#123; array = new Set(array); return Array.from(new Set([...target].filter(value =&gt; !array.has(value))));&#125; 第六部分数组包含指定目标。123456//判定数组是否包含指定目标function contains(target,item) &#123; return target.indexOf(item) &gt; -1;&#125; 最后模拟一下数组中的pop,push,shift和unshift的实现原理 12345678910111213141516const _slice = Array.prototype.slice;Array.prototype.pop = function() &#123; return this.splice(this.length - 1,1)[0];&#125;;Array.prototype.push = function() &#123; this.splice.apply(this,[this.length,0].concat(_slice.call(arguments))); return this.length;&#125;;Array.prototype.shift = function() &#123; return this.splice(0,1)[0];&#125;;Array.prototype.unshift = function() &#123; this.splice.apply(this, [0,0].concat(_slice.call(arguments))); return this.length;&#125;;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"闭包的相关用法","date":"2017-05-10T05:05:41.000Z","path":"2017/05/10/闭包的相关用法/","text":"[Don’t use closures unless you really need closure semantics.]不要使用闭包，除非你真正需要它。 [In most cases, non-nested functions are the right way to go.]请使用无嵌套函数。 什么是闭包123456789function a()&#123; var i=0; function b()&#123; alert(i); &#125; return b; &#125; var c = a(); c(); 全局变量c指定对 函数a的内部函数b的引用；内部函数b的执行需要依赖函数a的资源；这里就产生一个闭包，使得a在执行完毕并返回后，不会被javascript垃圾回收机制GC回收。因为这里c还在引用着b，而b依赖着a，故a在使用后，仍然存在于内存中。简而言之：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 闭包的应用场景1.使用闭包代替全局变量 2.函数外或在其他函数中访问某一函数内部的参数 3.在函数执行之前为要执行的函数提供具体参数 4.在函数执行之前为函数提供只有在函数执行或引用时才能知道的具体参数 5.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点 6.暂停执行 7.包装相关功能 1.使用闭包代替全局变量 全局变量有变量污染和变量安全等问题。12345678910111213141516171819202122//全局变量，test1是全局变量var test1=111 function outer()&#123; alert(test1);&#125;outer(); //111alert(test1); //111 //闭包，test2是局部变量，这是闭包的目的//我们经常在小范围使用全局变量，这个时候就可以使用闭包来代替。(function()&#123; var test2=222; function outer()&#123; alert(test2); &#125; function test()&#123; alert(\"测试闭包：\"+test2); &#125; outer(); //222 test(); //测试闭包：222&#125;)(); alert(test2); //未定义，这里就访问不到test2 2.函数外或在其他函数中访问某一函数内部的参数 为了解决在Ajax callback回调函数中经常需要继续使用主调函数的某一些参数。1234567891011121314function f1()&#123; var test=111; tmp_test=function()&#123;return test;&#125; //tmp_test是全局变量,这里对test的引用，产生闭包&#125;function f2()&#123; alert(\"测试一：\"+tmp_test()); var test1=tmp_test(); alert(\"测试二：\"+test1);&#125;f1();//测试一：111f2();//测试二：111alert(tmp_test()); //111tmp_test=null; 3.在函数执行之前为要执行的函数提供具体参数某些情况下，是无法为要执行的函数提供参数，只能在函数执行之前，提前提供参数。 有哪些情况是延迟执行？ 如：setTimeOutsetIntervalAjax callbacksevent handler[el.onclick=func 、 el.attachEvent(“onclick”,func)]12345678910111213141516171819202122232425262728//无法传参的情况var parm=222;function f1()&#123; alert(111);&#125;function f2(obj)&#123; alert(obj);&#125;setTimeout(f1,500);//正确,无参数var test1=f2(parm);//执行一次f2函数setTimeout(f2,500);//undefined，传参失败setTimeout(f2(parm),500);//参数无效，传参失败setTimeout(function(parm)&#123; alert(parm);&#125;,500);//undefined，传参失败document.getElementById(\"hello\").onclick=f1;//正确document.getElementById(\"hello\").attachEvent(\"onclick\",f1);//正确 //正确做法，使用闭包function f3(obj)&#123; return function()&#123; alert(obj); &#125;&#125;var test2=f3(parm);//返回f3的内部函数的引用setTimeout(test2,500);//正确,222document.getElementById(\"hello\").onclick=test2;//正确,222document.getElementById(\"hello\").attachEvent(\"onclick\",test2);//正确,222 4.在函数执行之前为函数提供只有在函数执行或引用时才能知道的具体参数123456789101112131415161718192021222324252627282930313233343536373839404142434445//动态绑定a集合的注册点击事件，在事件处理函数test1中提供参数-该点击事件的a元素本身。var aa=\"ha!\"function test(obj)&#123; return function()&#123; alert(obj); &#125;&#125;var nodes=document.getElementsByTagName(\"a\");for(var i=0;i&lt;nodes.length;i++)&#123; //由于是提前提供参数，只能提供已知的具体参数，无法事先得知点击事件的a元素本身。 var test1=test(aa); //这里想提供点击事件的a元素本身作为参数宣告失败！ //只有在注册点击事件时，才会知道该点击事件的a元素是哪个 nodes[i].onclick=test1;&#125; //以下是解决方式function associateObjWithEvent(obj,methodName)&#123; return (function(e)&#123; e=e||window.event; return obj[methodName](e,this);//重点看这里！有两个参数， //e:event，元素绑定事件时，绑定的是对内部函数的引用，故在触发事件时，执行的是内部函数。 //内部函数有个e参数，刚好在事件触发时，能捕获到是什么事件类型。 //this:这里需要的就是this参数，以便当元素触发事件处理函数执行时，this=触发事件的元素本身 //this参数无法从外部传入进来。传入进来的this都会被转化特定对象 &#125;);&#125;function htmlObject(elId)&#123; var el=document.getElementById(elId); if(el)&#123; //el.onclick=associateObjWithEvent(this,\"doOnClick\"); el.onmouseover=associateObjWithEvent(this,\"doMouseOver\"); el.onmouseout=associateObjWithEvent(this,\"doMouseOut\"); &#125;&#125;htmlObject.prototype.doMouseOver=function(event,element)&#123; alert(event);//第一个参数，只在事件执行时，才知道是什么事件，这里是MouseEvent alert(arguments[0]);//第一参数， alert(element);//第二个参数，只在事件执行时，才知道是指代触发事件的元素本身 alert(arguments[1]);//第二个参数&#125;var hello=new htmlObject(\"hello\"); //执行 另一个例子123456789101112131415161718192021222324function associateObjWithEvent(obj,methodName)&#123; return (function(e)&#123; e=e||window.event; return obj[methodName](e); &#125;);&#125;function DragListener()&#123; this.down=function()&#123; alert(this) alert(arguments[0]) &#125;, this.move=function()&#123; alert(2) &#125;&#125;var obj=new DragListener();document.getElementById(\"hello\").onmousedown =obj.down;//正确 但我们在方法中用this访问到的对象是 domdocument.getElementById(\"hello\").onmousemove = obj.move;//正确document.getElementById(\"hello\").onmousedown =associateObjWithEvent(obj,'down');//正确document.getElementById(\"hello\").onmousemove = associateObjWithEvent(obj,'move');//正确 改进的例子，无限参数1234567891011121314151617181920212223242526272829303132function associateObjWithEvent(obj, methodName)&#123; slice = Array.prototype.slice; var args=slice.call(arguments,2);//从第三个参数开始赋值 return (function(e)&#123; e = e||window.event; var array = slice.call(arguments, 0); array.push(e); //第一个参数为event return obj[methodName].apply(this,array.concat(args));//第二个参数，依次... &#125;);&#125;function htmlObject(elementId)&#123; var el = document.getElementById(elementId); if(el)&#123; //el.onclick = associateObjWithEvent(this, \"doOnClick\"); el.onmouseover = associateObjWithEvent(this, \"doMouseOver\",\"hello2\",\"aaa\",event); //第一个参数为event，hello2是第二个参数， //因为event只有在事件处理函数执行时才会知道是具体什么事件类型，无法通过传参提供，传参的event只能识别为null &#125;&#125;htmlObject.prototype.doMouseOver = function(event)&#123; // doMouseOver 方法体。 alert(\"this:\"+this.id);//this:hello alert(\"arg0:\"+arguments[0]) ;//arg0:MouseEvent alert(\"arg1:\"+arguments[1]);//arg1:hello2 alert(\"arg2:\"+arguments[2]);//arg2:aaa alert(\"arg3-event:\"+arguments[3]);//arg3-event:null alert(\"event:\"+event);//event:MouseEvent&#125;//htmlObject(\"hello\"); 这样写，反而出错。因为是类的写法，必须实例化才会执行。var hello=new htmlObject(\"hello\") 5.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点12345678910111213141516171819202122232425262728293031323334//假设有两个a链接，id分别为\"hello\"、\"world\"function test(obj)&#123; return function()&#123; alert(obj.id); &#125;&#125;var nodes=document.getElementsByTagName(\"a\");for(var i=0;i&lt;nodes.length;i++)&#123; var node=nodes[i]; //点击链接时，hello链接弹出world，world链接也弹出world； nodes[i].attachEvent(\"onclick\", function()&#123;alert(node.id)&#125;) //这是因为循环完毕后，node被赋值为world元素 //这不是我们预期的结果！！！ //正确写法一 // 内部参数parm为任意指定的参数,如： (function(node)&#123; return function()&#123; alert(node.id) &#125; &#125;)(node); nodes[i].attachEvent(\"onclick\",(function(parm)&#123; return function()&#123; alert(parm.id) &#125; &#125;)(node)); //第一次循环创建了一个闭包，缓存的node参数为hello链接。 //第二次循环又创建了一个闭包，缓存的node参数为world链接。 //点击链接时，hello链接弹出hello，world链接弹出world，因为他们调用的是各自的node参数 //正确写法二 var func=test(node); nodes[i].attachEvent(\"onclick\",func)&#125; 6.暂停执行 出处参考：http://ljchow.cnblogs.com 这个可以做很多实用和有意思的交互。 这个是无忧上月MM的例子，用闭包实现程序的暂停执行功能，还蛮创意的。1234567891011&lt;input type=\"button\" value=\"继续\" onclick='st();'/&gt; &lt;script type=\"text/javascript\"&gt; var st = (function() &#123; alert(1); alert(2); return function() &#123; alert(3); alert(4); &#125; &#125;)(); &lt;/script&gt; 把这个作用延伸下，我想到了用他来实现window.confirm。123456789101112131415161718192021222324252627282930313233343536373839&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;style type=\"text/css\"&gt; body &#123; font-family: Arial; font-size: 13px; background-color: #FFFFFF; &#125; #confirmDiv &#123; width: 200px; height: 100px; border: dashed 1px black; position: absolute; left: 200px; top: 150px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;input name=\"btn2\" type=\"button\" value=\"删除\" onclick=\"doConfirm('confirmDiv');\" /&gt; &lt;div id=\"confirmDiv\" style=\"display: none;\"&gt; &lt;div style='position: absolute; left: 50px; top: 15px;'&gt; &lt;p&gt;你确定要删除吗?&lt;/p&gt; &lt;input type=\"button\" value=\"确定\" onclick=\"doConfirm('confirmDiv')(true);\" /&gt; &lt;input type=\"button\" value=\"取消\" onclick=\"doConfirm('confirmDiv')(false);\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var $ = function(id) &#123; return \"string\" == typeof id ? document.getElementById(id) : id; &#125; var doConfirm = function(divId) &#123; $(divId).style.display = \"\"; function closeDiv() &#123; $(divId).style.display = \"none\"; &#125; return function(isOk) &#123; if (isOk) &#123; alert(\"Do deleting...\"); &#125; closeDiv(); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.包装相关功能 下面的代码定义了一个函数，这个函数用于返回一个 HTML 字符串，其中大部分内容都是常量，但这些常量字符序列中需要穿插一些可变的信息，而可变的信息由调用函数时传递的参数提供。 通过执行单行函数表达式返回一个内部函数，并将返回的函数赋给一个全局变量，因此这个函数也可以称为全局函数。而缓冲数组被定义为外部函数表达式的一个局部变量。它不会暴露在全局命名空间中，而且无论什么时候调用依赖它的函数都不需要重新创建这个数组。 如果一个函数依赖于另一（或多）个其他函数，而这些其他函数又没有必要被其他代码直接调用，那么可以运用相同的技术来包装这些函数，而通过一个公开暴露的函数来调用它们。这样，就将一个复杂的多函数处理过程封装成了一个具有移植性的代码单元。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /* 声明一个全局变量getImgInPositionedDivHtml并将一次调用一个外部函数表达式返回的内部函数赋给它。这个内部函数会返回一个用于表示绝对定位的DIV元素包围着一个IMG元素的HTML字符串，这样一来，所有可变的属性值都由调用该函数时的参数提供：*/ var getImgInPositionedDivHtml = (function()&#123; /* 外部函数表达式的局部变量 - buffAr - 保存着缓冲数组。 这个数组只会被创建一次，生成的数组实例对内部函数而言永远是可用的 因此，可供每次调用这个内部函数时使用。 其中的空字符串用作数据占位符，相应的数据 将由内部函数插入到这个数组中： */ var buffAr = [ '&lt;div id=\"', '', //index 1, DIV ID 属性 '\" style=\"position:absolute;top:', '', //index 3, DIV 顶部位置 'px;left:', '', //index 5, DIV 左端位置 'px;width:', '', //index 7, DIV 宽度 'px;height:', '', //index 9, DIV 高度 'px;overflow:hidden;\\\"&gt;&lt;img src=\\\"', '', //index 11, IMG URL '\\\" width=\\\"', '', //index 13, IMG 宽度 '\\\" height=\\\"', '', //index 15, IMG 调蓄 '\\\" alt=\\\"', '', //index 17, IMG alt 文本内容 '\\\"&gt;&lt;\\/div&gt;' ]; /* 返回作为对函数表达式求值后结果的内部函数对象。 这个内部函数就是每次调用执行的函数 - getImgInPositionedDivHtml( ... ) - */ return (function(url, id, width, height, top, left, altText)&#123; /* 将不同的参数插入到缓冲数组相应的位置： */ buffAr[1] = id; buffAr[3] = top; buffAr[5] = left; buffAr[13] = (buffAr[7] = width); buffAr[15] = (buffAr[9] = height); buffAr[11] = url; buffAr[17] = altText; /* 返回通过使用空字符串（相当于将数组元素连接起来） 连接数组每个元素后形成的字符串： */ return buffAr.join(''); &#125;); //:内部函数表达式结束。 &#125;)(); /*^^- :单行外部函数表达式。*///输出HTML字符串 document.write(getImgInPositionedDivHtml(\"www.baidu.com\",\"hello\",200,100,100,40,\"hello\"))","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"浏览器是如何渲染网页","date":"2017-05-02T05:05:41.000Z","path":"2017/05/02/浏览器是如何渲染网页/","text":"渲染网页时，不同的浏览器引擎运行起来会有些许差异，针对特定浏览器的具体内容更加复杂，现在总结一下一些共同的特点。 先了解一下浏览器是如何对网页进行渲染的： 浏览器将从服务器获取的HTML文档构建成文档对象模型DOM(Document Object Model). 载入和解析样式，构成层叠样式表模型CSSOM(CSS Object Model). 在DOM和CSSOM之上，渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象（这在Webkit内核中被称为renderer或者渲染对象render object，在Gecko内核中被称为框架frame）。渲染树映射除了不可见元素（例如或者含有display:none;的标签）外的所有DOM结构。每一段文本字符串都将划分在不同的渲染对象中，每一个渲染对象都包含了它相应的DOM对象以及计算后的样式。换句话讲，渲染树是DOM的直观表示。 渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout.浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素（tables需要多次pass绘制，pass表示像素处理和顶点处理）。最后布局完成，渲染树将转化为屏幕上的实际内容，这一步被称为绘制painting. 重绘Repaint当页面元素样式的改变不影响元素在文档流中的位置时（例如background-color,border-color,visibility）,浏览器只会将新样式赋予元素并进行重绘操作。 回流Reflow当改变影响文档内容或者结构，或者元素位置时，回流操作就会被触发，一般有以下几种情况： DOM操作（对元素的增删改，顺序变化等）； 内容变化，包括表单区域内的文本改变； CSS属性的更改或重新计算； 增删样式表内容； 修改class属性； 浏览器窗口变化（滚动或缩放）； 伪类样式激活（:hover等） 浏览器如何优化渲染浏览器本身会尽可能地减少其重绘或回流的次数，只更改必要的元素。例如一个position设置为absolute/fixed的元素的更改只会影响其本身和其子元素，而static的元素变化则会影响其之后的所有页面元素。 另外一项优化的技术则是在JavaScript代码运行时，浏览器会缓存所有的变化，然后只通过一次pass绘制操作来应用这些更改。例如下面这段代码只会触发一次重绘和回流：12345var $div = $('div');$div.css('padding','2px');//触发回流和重绘$div.css('color','red');//触发重绘$div.css('margin','5px');//触发回流和重绘//最终只有一次回流和重绘被触发 然而，根据我们之前提到过的，获取某个元素的属性将会触发强制回流。比如我们在刚才的代码中加上一句读取元素属性的操作：12345var $div = $('div');$div.css('padding','2px');$div.css('padding');//这里会强制回流$div.css('color','red');$div.css('margin','5px'); 结果就会有两次回流发生。因此，我们应该尽量合并读取元素属性的操作来优化性能。 当然也有我们不得不触发强制回流的情况。比如说对同一个元素的margin-left属性进行两次操作——开始的时候赋值100px的距离，之后为了实现动画效果，再加上transition属性将距离改变到50px. 我们先定义一个CSS类：123456.has-transition&#123; -webkit-transition: margin-left 1s ease-out; -moz-transition: margin-left 1s ease-out; -o-transition: margin-left 1s ease-out; transition: margin-left 1s ease-out;&#125; 之后再对页面元素进行操作：1234567891011121314//元素含有has-transition类$target_ele = $('#$target_eleid');//移除has-transition类$target_ele.removeClass('has-transition');//这里属性的改变没有动画$target_ele.css('margin-left',80);//再加上has-transition类$target_ele.addClass('has-transition');//这里属性的改变没有动画$target_ele.css('margin-left',40); 但事实上这段代码并不会像注释描述的那样运作，每条语句的操作将被缓存，只有结果会在页面上显示，所以我们就需要手动进行一次强制回流：12345678910111213141516//元素含有has-transition类$target_ele = $('#$target_eleid');//移除has-transition类$target_ele.removeClass('has-transition');//这里属性的改变没有动画$target_ele.css('margin-left',80);$target_ele.css('padding');//**这里触发强制回流**//再加上has-transition类$target_ele.addClass('has-transition');//这里属性的改变没有动画$target_ele.css('margin-left',40); 优化渲染效率的几条最佳实践根据我查阅的一些资料，总结出了几条优化建议： 合法地书写HTML和CSS，不要忘了文档编码类型。样式文件应当在 标签中，脚本文件在 结束前。简化并优化你的CSS选择器（有些人可能CSS预处理器用习惯了从来不关注这一点）。将嵌套层减少到最小。CSS选择器根据其优先级具有不同的运行效率（从快到慢）： ID选择器： #id 类选择器： .class 标签选择器： div 相邻选择器： a + i 子元素选择器： ul &gt; li 通用选择器： * 属性选择器： input[type=”text”] 伪类选择器： a:hover 浏览器中CSS选择器是从右到左进行匹配的（为什么浏览器要从右到左匹配样式选择器），这也是为什么越短的选择器运行越快的原因（别提通用选择器，它会遍历所有元素）：1234div * &#123;... ...&#125; //no.list li&#123;... ...&#125; //no.list-item&#123;... ...&#125; //yes#list .list-item&#123;... ...&#125; //yes 在你的脚本代码中，尽量减少DOM操作。缓存所有的内容，包括属性和对象（如果他们需要被复用的话）。尽量将元素缓存到本地之后再进行操作，最后再添加到DOM当中。 如果你使用jQuery进行DOM操作的话，最好遵循jQuery最佳实践。 修改元素样式时，更改其class属性是性能最高的方法。你的选择器越有针对性越好（这同样也有助于分离页面样式和逻辑）。 尽量只对 position 为 absolute/fixed 的元素设置动画。 在页面滚动时禁用 :hover 样式效果： 123.disable-hover&#123; pointer-events: none &#125; 12345678910var body = document.body,timer;window.addEventListener('scroll',function()&#123; clearTimeout(timer); if(!body.classList.contains('disable-hover'))&#123; body.classList.add('disable-hover') &#125; timer = setTimeout(function()&#123; body.classList.remove('disable-hover') &#125;,500);&#125;,false); 关于本文译者：@余博伦译文：https://zhuanlan.zhihu.com/p/25554352作者：@Alexander Skutin原文：What Every Frontend Developer Should Know About Webpage Rendering","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"渲染","slug":"渲染","permalink":"http://yoursite.com/tags/渲染/"}]},{"title":"Sublime text3安装LiveReload","date":"2017-04-28T05:05:41.000Z","path":"2017/04/28/Sublime text3安装LiveReload/","text":"LiveReload是很棒的插件，可以在浏览器中实时预览，但是在Sublime text3里，从Package Control中安装的LiveReload是无法使用的，但是可以选择手动安装解决。 LiveReload插件下载 Sublime端Github上的LiveReload for Sublime text3的地址： LiveReload ，两种方式安装: 方法一：选择DownloadZip，将解压的文件夹放在Packages文件夹（Preference&gt;Browse Packags）重启Sublime text3 方法二：直接clone到Packages文件夹。 //适用于Linux OSX //Windows可以通过Git操作 //进入Packages目录下 rm -rf LiveReload git clone https://github.com/Grafikart/ST3-LiveReload.git LiveReload 浏览器端我用的是chrome，在应用商店可以直接找到LiveReload，安装。 安装之后会出现这个图标。 配置方法一：Preference&gt;Package Settings&gt;LiveReload&gt;Settings User { &quot;enabled_plugins&quot;: [ &quot;SimpleReloadPlugin&quot;, &quot;SimpleRefresh&quot; ] } 方法二： ctrl+shift+p LiveReload: Enable/disable plugins Enable - SimpleReload实时预览 把html文件在浏览器中打开，点击一次图标中间的圆环变成原点就代表可以实时预览了。ST3中的文件保存一次，浏览器就会刷新一次，实时预览，很方便！","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"js同步异步","date":"2017-04-24T05:05:41.000Z","path":"2017/04/24/js同步异步/","text":"看了同步与异步，回调函数与Promise方面的知识，顺便记录下来 JS 中最基础的异步调用方式是callback，它将回调函数callback传给异步API，由浏览器或Node在异步完成后，通知 JS 引擎调用callback。对于简单的异步操作，用callback实现，是够用的。但随着负责交互页面和 Node 出现，callback 方案的弊端开始浮现出来。 Promise 规范孕育而生，并被纳入 ES6 的规范中。后来 ES7 又在 Promise 的基础上将 async 函数纳入标准。此为 JavaScript 异步发展过程。 同步与异步通常，代码是由上往下依次执行的。如果有多个任务，就必需排队，前一个任务完成，后一个任务才会执行。这种执行模式称之为：同步（synchronous）。新手容易把计算机用语中的同步，和日常用语中的同步弄混淆。如，“把文件同步到云端”中的同步，指的是“使…保持一致”。而在计算机中，同步指的是任务从上往下依次执行的模式。比如：123A();B();C(); 在这段代码中，A、B、C是三个不同的函数，每个函数都是一个不相关的任务。在同步模式，计算机会先执行 A任务，再执行 B 任务，最后执行C任务。在大部分情况，同步模式都没问题。但是如果B任务是一个耗时很长的网络请求，而 C 任务恰好是展现新页面，就会导致网页卡顿。 更好解决方案是，将 B 任务分成两个部分。一部分立即执行网络请求的任务，另一部分在请求回来后的执行任务。这种一部分立即执行，另一部分在未来执行的模式称为异步。1234567A();// 在现在发送请求 ajax('url1',function B() &#123; // 在未来某个时刻执行&#125;)C();// 执行顺序 A =&gt; C =&gt; B 实际上，JS 引擎并没有直接处理网络请求的任务，它只是调用了浏览器的网络请求接口，由浏览器发送网络请求并监听返回的数据。JavaScript 异步能力的本质是浏览器或 Node 的多线程能力。 callback未来执行的函数通常也叫 callback。使用callback的异步模式，解决了阻塞的问题，但是也带来了一些其他问题。在最开始，我们的函数是从上往下书写的，也是从上往下执行的，这种“线性”模式，非常符合我们的思维习惯，但是现在却被callback打断了！在上面一段代码中，现在它跳过 B 任务先执行了C任务！这种异步“非线性”的代码会比同步“线性”的代码，更难阅读，因此也更容易滋生 BUG。 试着判断下面这段代码的执行顺序，你会对“非线性”代码比“线性”代码更难以阅读，体会更深。123456789101112A();ajax('url1', function()&#123; B(); ajax('url2', function()&#123; C(); &#125; D();&#125;);E();// A =&gt; E =&gt; B =&gt; D =&gt; C 这段代码中，从上往下执行的顺序被 Callback 打乱了。我们的阅读代码视线是A =&gt; B =&gt; C =&gt; D =&gt; E，但是执行顺序却是A =&gt; E =&gt; B =&gt; D =&gt; C，这就是非线性代码带来的糟糕之处。 通过将ajax后面执行的任务提前，可以更容易看懂代码的执行顺序。虽然代码因为嵌套看起来不美观，但现在的执行顺序却是从上到下的“线性”方式。这种技巧在写多重嵌套的代码时，是非常有用的。12345678910A();E();ajax('url1', function()&#123; B(); D(); ajax('url2', function()&#123; C(); &#125;&#125;);// A =&gt; E =&gt; B =&gt; D =&gt; C 上一段代码只有处理了成功回调，并没处理异常回调。接下来，把异常处理回调加上，再来讨论代码“线性”执行的问题。1234567891011A();ajax('url1', function()&#123; B(); ajax('url2', function()&#123; C(); &#125;,function()&#123; D(); &#125;);&#125;,function()&#123; E();&#125;); 加上异常处理回调后，url1的成功回调函数 B 和异常回调函数 E，被分开了。这种“非线性”的情况又出现了。在 node 中，为了解决的异常回调导致的“非线性”的问题，制定了错误优先的策略。node 中 callback 的第一个参数，专门用于判断是否发生异常123456789101112131415A(); get('url1', function(error)&#123; if(error)&#123; E(); &#125;else &#123; B(); get('url2', function(error)&#123; if(error)&#123; D(); &#125;else&#123; C(); &#125; &#125;); &#125; &#125;); 到此，callback 引起的“非线性”问题基本得到解决。遗憾的是，使用callback嵌套，一层层ifelse和回调函数，一旦嵌套层数多起来，阅读起来不是很方便。此外，callback一旦出现异常，只能在当前回调函数内部处理异常。 promise在 JavaScript 的异步进化史中，涌现出一系列解决 callback 弊端的库，而 Promise 成为了最终的胜者，并成功地被引入了ES6中。它将提供了一个更好的“线性”书写方式，并解决了异步异常只能在当前回调中被捕获的问题。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise 就像一个中介，它承诺会将一个可信任的异步结果返回。首先Promise和异步接口签订一个协议，成功时，调用resolve函数通知 Promise，异常时，调用reject通知 Promise。另一方面 Promise 和 callback 也签订一个协议，由 Promise 在将来返回可信任的值给then和catch中注册的 callback。1234567891011// 创建一个 Promise 实例（异步接口和 Promise 签订协议）var promise = new Promise(function (resolve,reject) &#123; ajax('url',resolve,reject);&#125;);// 调用实例的 then catch 方法 （成功回调、异常回调与 Promise 签订协议）promise.then(function(value) &#123; // success&#125;).catch(function (error) &#123; // error&#125;) Promise 是个非常不错的中介，它只返回可信的信息给callback。它对第三方异步库的结果进行了一些加工，保证了 callback 一定会被异步调用，且只会被调用一次。1234567891011121314151617181920212223242526272829303132333435363738var promise1 = new Promise(function (resolve) &#123; // 可能由于某些原因导致同步调用 resolve('B');&#125;);// promise依旧会异步执行promise1.then(function(value)&#123; console.log(value)&#125;);console.log('A');// A B （先 A 后 B）var promise2 = new Promise(function (resolve) &#123; // 成功回调被通知了2次 setTimeout(function()&#123; resolve(); &#125;,0)&#125;);// promise只会调用一次promise2.then(function()&#123; console.log('A')&#125;);// A (只有一个)var promise3 = new Promise(function (resolve,reject) &#123; // 成功回调先被通知，又通知了失败回调 setTimeout(function()&#123; resolve(); reject(); &#125;,0)&#125;);// promise只会调用成功回调promise3.then(function()&#123; console.log('A')&#125;).catch(function()&#123; console.log('B')&#125;);// A（只有A） 介绍完 Promise 的特性后，来看看它如何利用链式调用，解决异步代码可读性的问题的。123456789101112131415161718192021var fetch = function(url)&#123; // 返回一个新的 Promise 实例 return new Promise(function (resolve,reject) &#123; ajax(url,resolve,reject); &#125;);&#125;A();fetch('url1').then(function()&#123; B(); // 返回一个新的 Promise 实例 return fetch('url2');&#125;).catch(function()&#123; // 异常的时候也可以返回一个新的 Promise 实例 return fetch('url2'); // 使用链式写法调用这个新的 Promise 实例的 then 方法 &#125;).then(function() &#123; C(); // 继续返回一个新的 Promise 实例...&#125;)// A B C ... 如此反复，不断返回一个 Promise 对象，再采用链式调用的方式不断地调用。使 Promise 摆脱了 callback 层层嵌套的问题和异步代码“非线性”执行的问题。 Promise 解决的另外一个难点是 callback 只能捕获当前错误异常。Promise 和 callback 不同，每个callback 只能知道自己的报错情况，但 Promise 代理着所有的 callback，所有 callback 的报错，都可以由 Promise 统一处理。所以，可以通过catch来捕获之前未捕获的异常。 Promise 解决了 callback 的异步调用问题，但 Promise 并没有摆脱 callback，它只是将 callback 放到一个可以信任的中间机构，这个中间机构去链接我们的代码和异步接口。 异步（async）函数异步（async）函数是 ES7 的一个新的特性，它结合了 Promise，让我们摆脱 callback 的束缚，直接用类同步的“线性”方式，写异步函数。 声明异步函数，只需在普通函数前添加一个关键字 async 即可，如async function main(){} 。在异步函数中，可以使用await关键字，表示等待后面表达式的执行结果，一般后面的表达式是 Promise 实例。123456async function main&#123; // timer 是在上一个例子中定义的 var value = await timer(100); console.log(value); // done （100ms 后返回 done）&#125;main(); 异步函数和普通函数一样调用 main() 。调用后，会立即执行异步函数中的第一行代码 var value = await timer(100)。等到异步执行完成后，才会执行下一行代码。 除此之外，异步函数和其他函数基本类似，它使用try…catch来捕捉异常。也可以传入参数。但不要在异步函数中使用return来返回值。123456789101112131415161718192021var timer = new Promise(function create(resolve,reject) &#123; if(typeof delay !== 'number')&#123; reject(new Error('type error')); &#125; setTimeout(resolve,delay,'done');&#125;);async function main(delay)&#123; try&#123; var value1 = await timer(delay); var value2 = await timer(''); var value3 = await timer(delay); &#125;catch(err)&#123; console.error(err); // Error: type error // at create (&lt;anonymous&gt;:5:14) // at timer (&lt;anonymous&gt;:3:10) // at A (&lt;anonymous&gt;:12:10) &#125;&#125;main(0); 异步函数也可以被当作值，传入普通函数和异步函数中执行。但是在异步函数中，使用异步函数时要注意，如果不使用await，异步函数会被同步执行。123456789101112async function main(delay)&#123; var value1 = await timer(delay); console.log('A')&#125;async function doAsync(main)&#123; main(0); console.log('B')&#125;doAsync(main);// B A 这个时候打印出来的值是 B A。说明 doAsync 函数并没有等待 main 的异步执行完毕就执行了 console。如果要让 console 在 main 的异步执行完毕后才执行，我们需要在main前添加关键字await。123456789101112async function main(delay)&#123; var value1 = await timer(delay); console.log('A')&#125;async function doAsync(main)&#123; await main(0); console.log('B')&#125;doAsync(main);// A B 由于异步函数采用类同步的书写方法，所以在处理多个并发请求，新手可能会像下面一样书写。这样会导致url2的请求必需等到url1的请求回来后才会发送。1234567891011121314151617var fetch = function (url) &#123; return new Promise(function (resolve,reject) &#123; ajax(url,resolve,reject); &#125;);&#125;async function main()&#123; try&#123; var value1 = await fetch('url1'); var value2 = await fetch('url2'); conosle.log(value1,value2); &#125;catch(err)&#123; console.error(err) &#125;&#125;main(); 使用Promise.all的方法来解决这个问题。Promise.all用于将多个Promise实例，包装成一个新的Promise实例，当所有的 Promise 成功后才会触发Promise.all的resolve函数，当有一个失败，则立即调用Promise.all的reject函数。12345678910111213141516var fetch = function (url) &#123; return new Promise(function (resolve,reject) &#123; ajax(url,resolve,reject); &#125;);&#125;async function main()&#123; try&#123; var arrValue = await Promise.all[fetch('url1'),fetch('url2')]; conosle.log(arrValue[0],arrValue[1]); &#125;catch(err)&#123; console.error(err) &#125;&#125;main(); 目前使用 Babel 已经支持 ES7 异步函数的转码了，大家可以在自己的项目中开始尝试。via：https://segmentfault.com/a/1190000006138882","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"JSON的一些理解","date":"2017-04-19T03:02:11.000Z","path":"2017/04/19/JSON的一些理解/","text":"使用JSON中注意的问题和JS中JSON.stringify、JSON.parse、以及不常见的toJSON的方法 先来看一个JS中常见的JS对象序列化成JSON字符串的问题，请问，以下JS对象通过JSON.stringify后的字符串是怎样的？先不要急着复制粘贴到控制台，先自己打开一个代码编辑器或者纸，写写看，写完再去仔细对比你的控制台输出，会返回什么呢?12345678910var friend=&#123; firstName: 'Good', 'lastName': 'Man', 'address': undefined, 'phone': [\"1234567\",undefined], 'fullName': function()&#123; return this.firstName + ' ' + this.lastName; &#125;&#125;;JSON.stringify(friend);//会返回什么呢？ 如果我想在最终JSON字符串将这个’friend’的姓名全部变成大写字母，也就是把”Good”变成”GOOD”，把”Man”变成”MAN”，那么可以怎么做？ 看完上面两个问题，我们再追本溯源看一下，JSON究竟是什么东西？为什么JSON易于数据交换？JSON和JS对象的区别？JS中JSON.parse、JSON.stringify和不常见的toJSON，这几个函数的参数和处理细节到底是怎样的？ 一、JSON是一种格式，基于文本，优于轻量，用于交换数1. 一种数据格式什么是格式？就是规范你的数据要怎么表示，举个栗子，有个人叫“二百六”，身高“160cm”，体重“60kg”，现在你要将这个人的这些信息传给别人或者别的什么东西，你有很多种选择： 姓名“二百六”，身高“160cm”，体重“60kg” name=”二百六”&amp;height=”160cm”&amp;weight=”60kg”&lt;person&gt;&lt;name&gt;二百六&lt;/name&gt;&lt;height&gt;160&lt;/height&gt;&lt;weight&gt;60&lt;/weight&gt;&lt;/person&gt; {“name”:”二百六”,”height”:160,”weight”:60} … … 以上所有选择，传递的数据是一样的，但是你可以看到形式是可以各式各样的，这就是各种不同格式化后的数据，JSON是其中一种表示方式。 2.基于文本的数据格式JSON是基于文本的数据格式，相对于基于二进制的数据，所以JSON在传递的时候是传递符合JSON这种格式(至于JSON的格式是什么，第二部分再说)的字符串，我们常会称为“JSON字符串”。 3.轻量级的数据格式在JSON之前，有一个数据格式叫xml，现在还是广泛在用，但是JSON更加轻量，如xml需要用到很多标签，像上面的例子中，你可以明显看到xml格式的数据中标签本身占据了很多空间，而JSON比较轻量，相同数据，以JSON的格式占据的带宽更小，这在有大量数据请求和传递的情况下是有明显优势的。 4.被广泛地用于数据交换轻量已经是一个用于数据交换的优势了，但更重要的JSON是易于阅读、编写和机器解析的，即这个JSON对人和机器都是友好的，而且又轻，独立于语言（因为是基于文本的），所以JSON被广泛用于数据交换。 以前端JS进行ajax的POST请求为例，后端PHP处理请求为例： 前端构造一个JS对象，用于包装要传递的数据，然后将JS对象转化为JSON字符串，再发送请求到后端； 后端PHP接收到这个JSON字符串，将JSON字符串转化为PHP对象，然后处理请求。 可以看到，相同的数据在这里有3种不同的表现形式，分别是前端的JS对象、传输的JSON字符串、后端的PHP对象，JS对象和PHP对象明显不是一个东西，但是由于大家用的都是JSON来传递数据，大家都能理解这种数据格式，都能把JSON这种数据格式很容易地转化为自己能理解的数据结构，这就方便啦，在其他各种语言环境中交换数据都是如此。 二、JSON和JS对象之间的关系经常看到“JSON是JS的一个子集”这句话，而且这句话我曾经也这么认为，每个符合JSON格式的字符串你解析成js都是可以的，直到后来发现了一个奇奇怪怪的东西… 1. 两个本质不同的东西为什么那么密切JSON和JS对象本质上完全不是同一个东西，就像“斑马线”和“斑马”，“斑马线”基于“斑马”身上的条纹来呈现和命名，但是斑马是活的，斑马线是非生物。 同样，”JSON”全名”JavaScript Object Notation”，所以它的格式（语法）是基于JS的，但它就是一种格式，而JS对象是一个实例，是存在于内存的一个东西。 说句玩笑话，如果JSON是基于PHP的，可能就叫PON了，形式可能就是这样的了[‘propertyOne’ =&gt; ‘foo’, ‘propertyTwo’ =&gt; 42]，如果这样，那么JSON可能现在是和PHP比较密切了。 此外，JSON是可以传输的，因为它是文本格式，但是JS对象是没办法传输的，在语法上，JSON也会更加严格，但是JS对象就很松散了。 那么两个不同的东西为什么那么密切，因为JSON毕竟是从JS中演变出来的，语法相近。 2. JSON格式别JS对象语法表现上严格在哪先就以“键值对为表现的对象”形式上，对比下两者的不同，至于JSON还能以怎样的形式表现，对比完后再罗列。 对比内容 JSON js 键名 必须加双引号 可不加或单双引号 属性值 10进制数值、字符串、布尔值、null、数组、符合JSON格式的对象、不能是函数、NAN、infinity、-infinity、undefined 无限制 逗号 最后一个不加逗号 无限制 数值 前导0不能用，小数点后必须有数字 无限制 可以看到，相对于JS对象，JSON的格式更严格，所以大部分写的JS对象是不符合JSON的格式的。 来看看例子：12345678910111213141516171819202122// 这只是 JS 对象var JSON_obj1 = &#123;&#125;; // JSON 格式的 JavaScript 对象 var JSON_obj2 = &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;;// JSON 格式的字符串var JSON_str1 = '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;';// JSON 格式的数组，是 JSON 的稍复杂一点的形式var JSON_arr = [ &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,];//稍复杂一点的 JSON 格式的字符串 var JSON_str2='['+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+']'; 另外，除了常见的“正常的”JSON格式，要么表现为一个对象形式{…}，要么表现为一个数组形式[…]，任何单独的一个10进制数值、双引号字符串、布尔值和null都是有效符合JSON格式的。 3. 一个有意思的地方，JSON不是JS的子集首先看下面的代码，你可以copy到控制台执行下：123var code = '\"\\u2028\\u2029\"'; JSON.parse(code); // 不报错eval(code); // 报错 这两个字符\\u2028和\\u2029分别表示行分隔符和段落分隔符，JSON.parse可以正常解析，但是当做js解析时会报错。 三、再来看看JS中的JSON函数在JS中我们主要会接触到两个JSON相关的函数，分别用于JSON字符串和JS数据结构之间的转化，一个叫JSON.stringify，它很聪明，聪明到你写的不符合JSON格式的JS对象都能帮你处理成符合JSON格式的字符串，所以你得知道它到底干了什么，免得它只是自作聪明，然后让你Debug long time；另一个叫JSON.parse，用于转化json字符串到JS数据结构，它很严格，你的JSON字符串如果构造地不对，是没办法解析的。 而它们的参数不止一个，虽然我们经常用的时候只传入一个参数。 此外，还有一个toJSON函数，我们较少看到，但是它会影响JSON.stringify。 1. 将JS数据结构转化为JSON字符串——JSON.stringify这个函数的函数签名是这样的：1JSON.stringify(value[, replacer [, space]]) 下面将分别展开带1~3个参数的用法，最后是它在序列化时做的一些“聪明”的事，要特别注意。 1.1 基本使用——仅需一个参数 这很简单，传入一个JSON格式的JS对象或者数组，JSON.stringify({“name”:”GoodMan”,”age”:18})返回一个字符串”{“name”:”Good Man”,”age”:18}”。 可以看到本身我们传入的这个JS对象就是符合JSON格式的，用的双引号，也没有JSON不接受的属性值，但如果像开头那个例子中的一样呢？不急，我们先举简单的例子来看看这个函数的几个参数的意义，再来说这个问题。 1.2 第二个参数可以是函数，也可以是一个数组 如果第二个参数是一个函数，那么序列化过程中的每个属性都会被这个函数转化和处理 如果第二个参数是一个数组，那么只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中 如果第二个参数是null，那作用上和空着没啥区别，但是不想设置第二个参数，只是想设置第三个参数的时候，就可以设置第二个参数为null 这第二个参数若是函数，看例子：123456789101112131415161718var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":\"1234567\", \"age\":18&#125;;var friendAfter=JSON.stringify(friend,function(key,value)&#123; if(key===\"phone\") return \"(010)\"+value; else if(typeof value === \"number\") return value + 10; else return value; //如果把这个else删除，那么结果会是undefined&#125;);console.log(friendAfter); //输出：&#123;\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":\"(010)1234567\",\"age\":28&#125; 如果制定了第二个参数是函数，那么这个函数必须对每一项都有返回，这个函数接受两个参数，一个键名，一个是属性值，函数必须针对每一个原来的属性值都要有新属性值的返回。 那么问题来了，如果传入的不是键值对的对象形式，而是方括号的数组形式呢？，比如上面的friend变成这样：friend=[“Jack”,”Rose”]，那么这个逐属性处理的函数接收到的key和value又是什么？如果是数组形式，那么key是索引，而value是这个数组项，你可以在控制台在这个函数内部打印出来这个key和value验证。 这第二个参数若是数组，看例子：123456789101112var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":\"1234567\", \"age\":18&#125;;//注意下面的数组有一个值并不是上面对象的任何一个属性名var friendAfter=JSON.stringify(friend,[\"firstName\",\"address\",\"phone\"]);console.log(friendAfter); //&#123;\"firstName\":\"Good\",\"phone\":\"1234567\"&#125;//注意看，指定的“address”由于没有在原来的对象中找到而被忽略 所以如果第二个参数是一个数组，那么只有在数组中出现的属性才会被序列化进结果字符串，只要在这个提供的数组中找不到的属性就不会被包含进去，而这个数组中存在但是源JS对象中不存在的属性会被忽略，不会报错。 1.3 第三个参数用于美化输出——不建议用 指定缩进用的空白字符，可以取以下几个值： 是1-10的某个数字，代表用几个空白字符 是字符串的话，就用该字符串代替空格，最多取这个字符串的前10个字符 没有提供该参数 等于 设置成null 等于 设置一个小于 1 的数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":&#123;\"home\":\"1234567\",\"work\":\"7654321\"&#125;&#125;;//直接转化是这样的：//&#123;\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":&#123;\"home\":\"1234567\",\"work\":\"7654321\"&#125;&#125;var friendAfter=JSON.stringify(friend,null,4); console.log(friendAfter); /*&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\": &#123; \"home\": \"1234567\", \"work\": \"7654321\" &#125;&#125;*/var friendAfter=JSON.stringify(friend,null,\"HAHAHAHA\"); console.log(friendAfter); /*&#123;HAHAHAHA\"firstName\": \"Good\", HAHAHAHA\"lastName\": \"Man\", HAHAHAHA\"phone\": &#123; HAHAHAHAHAHAHAHA\"home\": \"1234567\", HAHAHAHAHAHAHAHA\"work\": \"7654321\" HAHAHAHA&#125; &#125;*/var friendAfter=JSON.stringify(friend,null,\"WhatAreYouDoingNow\"); console.log(friendAfter); /* 最多只取10个字符&#123;WhatAreYou\"firstName\": \"Good\", WhatAreYou\"lastName\": \"Man\", WhatAreYou\"phone\": &#123; WhatAreYouWhatAreYou\"home\": \"1234567\", WhatAreYouWhatAreYou\"work\": \"7654321\" WhatAreYou&#125; &#125;*/ 但是别这样用，序列化是为了传输，传输当然是能越小越好，加莫名其妙的缩进符，解析困难（如果是字符串的话），也弱化了轻量化这个特点。。 1.4 注意这个函数的“小聪明”（注意） 如果有其他不确定的情况，那么最好的办法就是code，控制台看下输出就明了了。 键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号 最后一个属性后面有逗号的，会被自动去掉 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值也就是你的什么new String(“bala”)会变成”bala”，new Number(2017)会变成2017 undefined、任意的函数（其实有个函数会发生神奇的事，后面会说）以及 symbol 值（symbol详见ES6对symbol的介绍） 出现在非数组对象的属性值中：在序列化过程中会被忽略 出现在数组中时：被转换成 null1234JSON.stringify(&#123;x: undefined, y: function()&#123;return 1;&#125;, z: Symbol(\"\")&#125;); //出现在非数组对象的属性值中被忽略：\"&#123;&#125;\"JSON.stringify([undefined, Object, Symbol(\"\")]); //出现在数组对象的属性值中，变成null：\"[null,null,null]\" NaN、Infinity和-Infinity，不论在数组还是非数组的对象中，都被转化为null 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们 不可枚举的属性会被忽略 2.将JSON字符串解析为JS数据结构——JSON.parse这个函数的函数签名是这样的：1JSON.parse(text[, reviver]) 如果第一个参数，即JSON字符串不是合法的字符串的话，那么这个函数会抛出错误，所以如果你在写一个后端返回JSON字符串的脚本，最好调用语言本身的JSON字符串相关序列化函数，而如果是自己去拼接实现的序列化字符串，那么就尤其要注意序列化后的字符串是否是合法的，合法指这个JSON字符串完全符合JSON要求的严格格式。 值得注意的是这里有一个可选的第二个参数，这个参数必须是一个函数，这个函数作用在属性已经被解析但是还没返回前，将属性处理后再返回。123456789101112131415161718192021222324252627282930313233343536373839404142var friend=&#123; \"firstName\": \"Good\", \"lastName\": \"Man\", \"phone\":&#123;\"home\":\"1234567\",\"work\":[\"7654321\",\"999000\"]&#125;&#125;;//我们先将其序列化var friendAfter=JSON.stringify(friend); //'&#123;\"firstName\":\"Good\",\"lastName\":\"Man\",\"phone\":&#123;\"home\":\"1234567\",\"work\":[\"7654321\",\"999000\"]&#125;&#125;'//再将其解析出来，在第二个参数的函数中打印出key和valueJSON.parse(friendAfter,function(k,v)&#123; console.log(k); console.log(v); console.log(\"----\");&#125;);/*firstNameGood----lastNameMan----home1234567----07654321----1999000----work[ , ]----phone&#123;&#125;----&#123;&#125;----*/ 仔细看这些输出，可以发现这个遍历是由内而外的，可能由内而外这个词大家会误解，最里层是内部数组里的两个值啊，但是输出是从第一个属性开始的，怎么就是由内而外的呢？ 这个由内而外指的是对于复合属性来说的，通俗地讲，遍历的时候，从头到尾进行遍历，如果是简单属性值（数值、字符串、布尔值和null），那么直接遍历完成，如果是遇到属性值是对象或者数组形式的，那么暂停，先遍历这个子JSON，而遍历的原则也是一样的，等这个复合属性遍历完成，那么再完成对这个属性的遍历返回。本质上，这就是一个深度优先的遍历。 有两点需要注意： 如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。 你可以注意到上面例子最后一组输出看上去没有key，其实这个key是一个空字符串，而最后的object是最后解析完成对象，因为到了最上层，已经没有真正的属性了。 3.影响 JSON.stringify 的神奇函数——object.toJSON如果你在一个JS对象上实现了toJSON方法，那么调用JSON.stringify去序列化这个JS对象时，JSON.stringify直接调用这个对象的toJSON方法，将其返回的值作为参数去进行序列化。1234567891011var info=&#123; \"msg\":\"I Love You\", \"toJSON\":function()&#123; var replaceMsg=new Object(); replaceMsg[\"msg\"]=\"Go Die\"; return replaceMsg; &#125;&#125;;JSON.stringify(info); //返回的是：&#123;\"msg\":\"Go Die\"&#125;,说好的忽略函数呢,所以说它很神奇 类似的，Date类型可以直接传给JSON.stringify做参数，其中的原理就是，Date类型内置了toJSON方法。 四、关于兼容性的问题遗憾的是，以上所用的3个函数，不兼容IE7以及IE7之前的浏览器。有关兼容性的讨论，留待之后吧。如果想直接在应用上解决兼容性，那么可以套用JSON官方的js来解决。 本文是看到网上的文章整理出来的，原作者@Stinson Zhao","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"BFC","date":"2017-04-08T09:09:12.000Z","path":"2017/04/08/BFC与外边距折叠/","text":"块级格式化上下文(BFC)与边距折叠 需要注意的是切忌把触发BFC与消除边距折叠等同。 块级格式化上下文，Block formatting context(简称BFC)，规定了块级盒子的渲染布局方式，他在计算盒子高度，margin值计算等地方有区别于其他环境。CSS标准里的描述： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents. BFC有什么特点 内部盒子会在垂直方向排列 同一个BFC中的元素可能会发生margin collapse BFC就是页面上的一个隔离的独立容器，里外互相不影响 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算 浮动盒区域不叠加到BFC上 什么元素会触发产生一个新的BFC 根元素 float属性不为none position为absolute或fixed display为inline­block, table­cell, table­caption, flex, inline­flex overflow不为visible认真看下面的例子：我们可以用BFC来干嘛 清除浮动 阻止边距折叠 用于布局，什么两栏自适应高度之类的 BFC兼容性IE6，7不支持BFC，而是使用私有属性hasLayout。表现上来看hasLayout和BFC相似，触发hasLayout条件与BFC相似，另外需要为元素设置IE特有的CSS属性zoom:1;zoom用于设置或检索元素的缩放比例，值为1即使用元素实际尺寸，使用zoom既可以触发hasLayout又不会对元素产生其他影响，相对来说更加方便 collapsing margins（边距折叠） 什么时候发生外边距折叠：垂直方向上的处于同一个BFC上的相邻外边距。 相邻意味着没有被padding、border、行框和clearance分隔开（clearance就是clear引起的位移，比如一个浮动元素50px高，他后面跟了一个设置了clear的元素，假如clear起作用，并且在垂直方向上将这个元素向下推离了。那么被移动的这50px就是clearance，如果后一个元素自带60px的上外边距，那么即使设置了clear，也不会产生推移，也就没有clearance）。 相邻也意味着多种情况，只要处于同一个BFC当中，父元素的上外边距就会和第一个子元素的上外边距重叠。如果父元素其height为auto其下外边距也会最后一个子元素的下外边距重叠。对于min-height计算值为0的情况，比如说一个没有内容没有高度没有边框没有padding的div，其自身的上下边距也会也会重叠，这也就是自身的上下边距相邻。同时在这种情况下，如果这个0高元素上没有clearance，他还可以后续元素的外边距甚至是父元素的下外边距重叠。 但是如果有clearance，则不会与父元素的下外边距重叠。这个有clearance的特例情况在IE和FireFox下有，Chrome下只要有clear，不管有没有推出clearance都不会和父元素的下外边距重叠。 上面说明白了是处于同一个BFC中才发生外边距折叠。而在一个元素上触发BFC，是为该元素的子元素新建了一个BFC，而这个元素并没有被包含在这个新BFC中，因此两个相邻的发生边距折叠的兄弟元素，分别在他们身上触发BFC并不会取消边距折叠。 不发生外边距折叠的情况：浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠。 这里看起来跟会触发BFC的情况很相似，但是其实还是差距很大的，所以一定要区分BFC和边距重叠。最好单独记忆不发生外边距重叠的情况。 CSS定位方案css布局宏观上来说是受定位方案影响，定位方案包括普通流，浮动，定位 普通流元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述只要不是float和绝对定位方式布局的，都在普通流里面。浮动 浮动框不在文档的普通流中，浮动的流会漂浮在普通的流上面。浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 定位 相对定位在普通流之中，是相对于它在普通流中的位置中进行移动，元素占据原来位置 绝对定位脱离普通流，不占据空间相对于距离它最近的那个已定位的祖先(相对/绝对)元素决定的。 固定定位，相对于浏览器窗口定位，脱离普通流，不占据空间","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"BFC","slug":"BFC","permalink":"http://yoursite.com/tags/BFC/"}]},{"title":"js设计模式(二)","date":"2017-04-05T09:09:12.000Z","path":"2017/04/05/设计模式（二）/","text":"包括代理模式，迭代器模式以及观察者模式 代理模式单例模式的关键是当客户不方便直接访问一个对象或者不满足需要的时候，提供一个对象来控制对这个对象访问，客户实际访问的是替身对象。替身对象对请求作出一些处理后再把请求转给本体对象 现在我们假定一个场景，女神A在心情好的时候收到花，小明表白成功的几率有60%，而A心情不好时几率几乎为0.但小明不知道A什么时候心情好，可是女神A的闺蜜B知道啊，所以小明打算先把花给B，等到A心情好时再转交，这样成功几率杠杠的。12345678910111213141516171819202122232425var Flower = function()&#123;&#125;;var xiaoming = &#123; sendFlower:function(target)&#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;;var B = &#123; receiveFlower: function(flower)&#123; A.listenGoodMood(function()&#123; A.receiveFlower(flower); &#125;); &#125;&#125;;var A = &#123; receiveFlower: function(flower)&#123; console.log('收到花' + flower); &#125;, listenGoodMood: function(fn)&#123; setTimeout(function()&#123; fn(); &#125;,1000); &#125;&#125;;xiaoming.sendFlower(B); 上面是一个简单的代理模式例子，接下来说一下在JavaScript开发中常见的虚拟代理和缓存代理； 虚拟代理把一些开销大的对象延迟到真正需要的时候再创建1.可用在合并HTTP请求，如收集规定时间段内想要发起得到HTTP请求，然后再一次性发起请求2.用在惰性加载中 可以用虚拟代理实现图片预加载12345678910111213141516171819202122var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src)&#123; imgNode.src = src; &#125; &#125;;&#125;)();var proxyImage = (function()&#123; var img = new Image; img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src)&#123; myImage.setSrc('proxy_url'); img.src = src; &#125; &#125;; &#125;)();proxyImage.setSrc('url'); 通过proxyImage间接访问myImage，在此过程中，添加操作，例子中是当url图片加载完成之前，使用一个本地的菊花图代替； 但是一定需要用虚拟代理模式吗？先看一下不用代理模式的图片预加载函数1234567891011121314var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src)&#123; myImage.setSrc('url'); img.src = src; &#125; &#125;;&#125;)();myImage.setSrc('url'); 至于为什么推荐用代理模式呢，那么就得说说面向对象设计的原则————单一职责原则单一职责原则指的是，就一个类(也包括对象和函数等)而言，应该仅有一个引起它变化的原因。如果一个对象承担了很多职责，就意味着对象会变得庞大，引起它变化的原因可能有多个。面向对象设计鼓励将行为分布到细粒度的对象中，如果一个对象承担的职责过多，相当于把职责耦合在一起，这会导致脆弱和低内聚的设计。当变化发生时，设计可能遭到意外破坏 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递的参数跟之前的一致，那么可以直接返回前面的结果，也可用在ajax异步请求数据; 如计算乘积12345678910111213141516171819202122var mult = function()&#123; console.log('开始计算'); var a =var mult = function()&#123; console.log('开始计算'); var a = 1; for ( var i = 0,l = arguments.length;i &lt; l;i++)&#123; a = a*arguments[i]; &#125; return a;&#125;;var proxyMult = (function()&#123; var cache = []; return function()&#123; var args = Array.prototype.join.call(arguments, ','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = mult.apply(this,arguments);; &#125;;&#125;)();proxyMult(1,2,3,4);proxyMult(1,2,3,4); 迭代器模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。现在大多数都内置了迭代器实现，，如Array.prototype.forEach 下面用内部迭代器实现的一个简单迭代器，比较两个数组的元素:1234567891011121314151617var each = function(ary,callback)&#123; for (var i = 0,l = ary.length; i &lt; l; i++) &#123; callback.call(ary[i],i,ary[i]); &#125;&#125;;var compare = function(ary1,ary2)&#123; if(ary1.length !== ary2.length)&#123; console.log('不相等')； &#125; each(ary1,function(i,n)&#123; if(n !== ary2[i])&#123; console.log(\"不相等\"); &#125; &#125;)； console.log(\"相等\");&#125;compare([1,2,3],[1,2,4]); 这是利用js中能把函数当成参数传递的特性才完成的，但在其他语言是行不通的。那么来看另一种实现方法 外部迭代器必须显式地请求迭代下一个元素，虽然增加了调用的复杂度，但增加了灵活性123456789101112131415161718192021222324252627282930var Iter = function(obj)&#123; var current = 0; var next = function()&#123; current +=1; &#125;; var isDone = function()&#123; return current &gt;= obj.length; &#125;; var getCurrTtem = function()&#123; return obj[current]; &#125;; return &#123; next: next, isDone: isDone, getCurrTtem: getCurrTtem &#125;;&#125;;var compare = function(iter1,iter2)&#123; while(!iter1.isDone()&amp;&amp;!iter2.isDone())&#123; if(iter1.getCurrTtem()!==iter2.getCurrTtem())&#123; console.log(\"不相等\"); &#125; iter1.next(); iter2.next(); &#125; console.log(\"相等\");&#125;;var iter1 = Iter([1,2,3]);var iter2 = Iter([1,2,4]);compare(iter1,iter2); 发布-订阅者模式(观察者模式)定义对象间的一种一对一的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知，js中用事件模型替代传统的发布-订阅模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var Event = (function()&#123; var clientList = &#123;&#125;, listen, trigger, remove; // 监听消息 listen = function(key,fn)&#123; if(!clientList[key])&#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; //发布消息 trigger = function()&#123; var key = Array.prototype.shift.call(arguments),fns = clientList[key]; if(!fns || fns.length === 0 )&#123; return false; &#125; for (var i = 0,fn ;fn = fns[i++];)&#123; fn.apply(this,arguments); &#125; &#125;; //取消订阅 remove = function(key,fn)&#123; var fns = clientList[ key ]; if(!fns)&#123; return false; &#125; if(!fn)&#123; fns &amp;&amp; (fns.length = 0); &#125;else&#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[ l ]; if(_fn === fn)&#123; fns.splice(l,1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;;&#125;)();Event.listen('s88',function(price)&#123; console.log('价格='+price);&#125;);Event.listen('s100',function(price)&#123; console.log('价格='+price);&#125;);Event.trigger('s88',100);Event.trigger('s100',200); 这是一个用全局的Event对象来实现的订阅-发布模式，订阅者不需要知道消息来着哪个发布者，发布者也不需要消息会推送给谁，就类似于一个全托的房屋中介。","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"js设计模式(一)","date":"2017-04-01T09:09:12.000Z","path":"2017/04/01/设计模式（一）/","text":"包括单例模式，策略模式 1.单例模式单例模式的核心是确保只有一个实例，并提供全局访问在js中，全局变量也符合这两个条件，就是说可以当成单例使用如var a = {},但是它很容易造成命名空间污染，随时有可能被覆盖，我们应尽量减少全局变量的使用方法有：1.使用命名空间2.使用闭包封装私有变量 通用的惰性单例 例子：新建一个登录div 1234567891011121314151617181920212223//业务逻辑（创建对象）var createLoginLayer = function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;//创建单例var getSingle = function( fn )&#123; var result; return function()&#123; return result||( result = fn.apply(this, arguments) ); &#125;;&#125;;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginbtn').onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;; 单例模式是比较简单却很实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。奇妙的是，创建对象和管理单例的职责分布在两个方法中，两个方法组合才具有单例模式的威力。 2.策略模式定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换 例子：元素（小球）页面中运动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//运动算法var tween =&#123; linear:function(t,b,c,d)&#123; return c*t/d + b; &#125;, easeIn:function(t,b,c,d)&#123; return c*(t/=d)*t+b; &#125;, strongEaseIn:function(t,b,c,d)&#123; return c*(t/=d)*t*t*t*t +b; &#125;, strongEaseOut:function(t,b,c,d)&#123; return c*((t=t/d-1)*t*t*t*t+1) +b; &#125;, sineasIn:function(t,b,c,d)&#123; return c*(t/=d)*t*t +b; &#125;, sineasOut:function(t,b,c,d)&#123; return c*((t=t/d-1)*t*t+1) +b; &#125;,&#125;;//运动的元素节点var Animate = function(dom)&#123; this.dom = dom; this.startTime = 0; this.startPos = 0; this.endPos = 0; this.propertyName = null; this.easing = null; this.duration = null;&#125;;// 启动/停止动画，记录信息Animate.prototype.start = function(propertyName,endPos,duration,easing)&#123; this.startTime = +new Date; //启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; //初始位置 this.propertyName = propertyName; //改变的CSS属性 this.endPos = endPos; //目标位置 this.duration = duration; //持续时间 this.easing = tween[easing]; //运动算法 var self =this; var timeId = setInterval(function()&#123; if(self.step() === false)&#123; clearInterval(timeId); &#125; &#125;,19);&#125;;//每一帧做的操作Animate.prototype.step = function()&#123; var t =+new Date; if (t &gt;= this.startTime+this.duration) &#123; this.update(this.endPos); //更新位置 return false; &#125; var pos = this.easing(t-this.startTime,this.startPos,this.endPos-this.startPos,this.duration); //运动算法 this.update(pos);&#125;;Animate.prototype.update = function(pos)&#123; this.dom.style[this.propertyName] = pos +'px';&#125;;var div = document.getElementById('div');var animate = new Animate(div);animate.start('left',500,1000,'strongEaseOut'); 策略模式是一种常见且有效的设计模式，他的优点有： 利用组合，委托和多态等技术思想，有效避免多重条件选择语句 提供对开放-封闭原则的支持，将算法封装在独立的strategy中，方便切换 算法可以复用在系统的其他地方，避免重复复制 利用组合和委托让context拥有执行算法的能力，这是继承的一种替代方案缺点：程序会增加许多策略类或对象；必须了解各个strategy之间的不同点，才能选择合适的strategy；","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"常见js算法汇总(三)","date":"2017-03-30T12:09:12.000Z","path":"2017/03/30/常见算法汇总（三）/","text":"基数排序，计数排序，桶排序 基数排序基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； 12345678910111213141516171819202122232425262728293031323334353637/** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数*///LSD Radix Sortfunction radixSort(arr,maxDigit)&#123; varmod=10; vardev=1; varcounter=[]; console.time('基数排序耗时'); for(vari=0;i&lt;maxDigit;i++,dev*=10,mod*=10)&#123; for(varj=0;j&lt;arr.length;j++)&#123; varbucket=parseInt((arr[j]%mod)/dev); if(counter[bucket]==null)&#123; counter[bucket]=[]; &#125; counter[bucket].push(arr[j]); &#125; varpos=0; for(varj=0;j&lt;counter.length;j++)&#123; varvalue=null; if(counter[j]!=null)&#123; while((value=counter[j].shift())!=null)&#123; arr[pos++]=value; &#125; &#125; &#125; &#125; console.timeEnd('基数排序耗时'); returnarr;&#125;vararr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(radixSort(arr,2));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 计数排序最佳情况：T(n) = O(n+k)最差情况：T(n) = O(n+k)平均情况：T(n) = O(n+k) . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 1234567891011121314151617181920212223function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd('计数排序耗时'); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 7, 2, 1, 4, 2, 4, 7, 2, 5];console.log(countingSort(arr)); 桶排序最佳情况：T(n) = O(n+k)最差情况：T(n) = O(n+k)平均情况：T(n) = O(n2) .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 12345678910111213141516171819202122232425262728293031323334353637383940/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; //非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd('桶排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4)); 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶计数排序：每个桶只存储单一键值桶排序： 每个桶存储一定范围的数值","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"常见js算法汇总(二)","date":"2017-03-29T03:09:12.000Z","path":"2017/03/29/常见算法汇总（二）/","text":"接着上一篇博客,选择排序与归并排序 选择法排序选择法主要有三种： . 简单的选择排序：其实基本的思想就是从待排序的数组中选择最小或者最大的，放在起始位置，然后从剩下的数组中选择最小或者最大的排在这公司数的后面。1234567891011121314151617function selectionSort(data)&#123; var i, j, min, temp , count=data.length; for(i = 0; i &lt; count - 1; i++) &#123; // find the minimum min = i; for (j = i+1; j &lt; count; j++)&#123; if (data[j] &lt; data[min])&#123; min = j; &#125; &#125; // swap data[i] and data[min] temp = data[i]; data[i] = data[min]; data[min] = temp; &#125; return data;&#125; 树型排序：又称锦标赛排序，首先对n个元素进行两两比较，然后在其中[n/2]个较小者再进行两两比较如此重复直至选出最小的关键字的纪录为止。（可用完全二差树表示）。缺点：辅助空间需求过大，和“最大值”进行多余比较12 堆排序：（不适用于纪录数较少的文件） 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(nlogn)平均情况：T(n) = O(nlogn) .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd('堆排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number')&#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 归并排序所谓归并就是将两个或者两个以上的有序表合成一个新的有序表。递归形式的算法在形式上较为简洁但实用性较差，与快速排序和堆排序相比，归并排序的最大特点是，它是一种稳定的排序方法。 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 12345678910111213141516171819202122232425262728293031323334function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length)&#123; result.push(left.shift()); &#125; while (right.length)&#123; result.push(right.shift()); &#125; console.timeEnd('归并排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); 将有二个有序数列a[first…mid]和a[mid…last]合并。123456789101112131415161718192021222324252627282930313233function mergearray(Arr,first,mid,last,tempArr)&#123; var i = first, j = mid + 1; var m = mid, n = last; var k = 0; while (i &lt;= m &amp;&amp; j &lt;= n)&#123; if (Arr[i] &lt; Arr[j])&#123; tempArr[k++] = Arr[i++]; &#125;else&#123; tempArr[k++] = Arr[j++]; &#125; while (i &lt;= m)&#123; tempArr[k++] = Arr[i++]; &#125; while (j &lt;= n)&#123; tempArr[k++] = Arr[j++]; &#125; for (i = 0; i &lt; k; i++)&#123; Arr[first + i] = tempArr[i]; &#125;&#125;function mergesort(Arr,first,last)&#123; var tempArr=new Array(); if (first &lt; last)&#123; var mid = (first + last)&gt;&gt;&gt;1; mergesort(Arr, first, mid, tempArr); //左边有序 mergesort(Arr, mid + 1, last, tempArr); //右边有序 mergearray(Arr, first, mid, last, tempArr); //再将二个有序数列合并 &#125; return Arr;&#125;var Arr=new Array(1,65,45,98,56,78);alert(mergesort(Arr,0,Arr.length-1));","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"常见算法汇总(一)","date":"2017-03-28T07:19:35.000Z","path":"2017/03/28/常见算法汇总（一）/","text":"写这篇文章是因为之前学了一些常见算法，并随手记录了下来，然而当时并没有博客，这不，有了博客马上放上来了，有去重，二分法，冒泡，插入1. 数组去重1234567891011121314151617function delRepeat(arr)&#123; var newArray=new Array(); var len=arr.length; for(var i=0;i&lt;len;i++)&#123; for(var j=i+1;j&lt;len;j++) &#123; if(arr[i]==arr[j]) &#123; ++i; &#125; &#125; newArray.push(arr[i]); &#125; return newArray;&#125;var arr=new Array(\"red\",\"red\",\"1\",\"5\",\"2\");alert(delRepeat(arr)); 2.求字符串长度的方法 12345678910function GetBytes(str)&#123; var len=str.length, bytes=len; for(var i=0;i&lt;len;i++)&#123; if(str.CharCodeAt&gt;255)&#123; bytes++; &#125; &#125; return bytes;&#125; 3.二分法 又称为折半查找算法，但是有缺陷就是要求数字是预先排序好的 1234567891011121314function binary(items,value)&#123; var startIndex=0, stopIndex=items.length-1, midlleIndex=(startIndex+stopIndex)&gt;&gt;&gt;1; while(items[middleIndex]!=value &amp;&amp; startIndex&lt;stopIndex)&#123; if(items[middleIndex]&gt;value)&#123; stopIndex=middleIndex-1; &#125;else&#123; startIndex=middleIndex+1; &#125; middleIndex=(startIndex+stopIndex)&gt;&gt;&gt;1; &#125; return items[middleIndex]!=value ? false:true;&#125; 4.实现递归 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125; 但是这在js里面可能会出现错误，如： 123var anotherFactorial = factorial;factorial=null;alert(anoterFactorial(4)); 因为在调用anoterFactorial时内部的factorial已经不存在了。解决方法是通过arguments.callee来解决。如下： 12345678910function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125; var anotherFactorial = factorial; factorial = null; alert(anotherFactorial(4));//成功！！！&#125; 5.冒泡排序 12345678910111213function bullSort(array)&#123; var temp; for(var i=0;i&lt;array.length;i++)&#123; for(var j=array.length-1;j&gt;i;j--)&#123; if(array[j]&lt;array[j-1])&#123; temp = array[j]; array[j]=array[j-1]; array[j-1]=temp; &#125; &#125; &#125; return array;&#125; 6.快速排序 其实说到底快速排序算法就系对冒泡排序的一种改进，采用的就是算法理论中的分治递归的思想,做法就是：通过一趟排序将待排序的纪录分割成两部分，其中一部分的纪录值比另外一部分的纪录值要小，就可以继续分别对这两部分纪录进行排序；不段的递归实施上面两个操作，从而实现纪录值的排序。 12345678910111213141516171819202122232425function sort(arr)&#123; return quickSort(arr,0,arr.length-1); function quickSort(arr,l,r)&#123; if(l&lt;r)&#123; var mid=arr[parseInt((l+r)/2)],i=l-1,j=r+1; while(true)&#123; //大的放到右边，小的放到左边, i与j均为游标 while(arr[++i]&lt;mid); while(arr[--j]&gt;mid); if(i&gt;=j)break;//判断条件 var temp = arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; quickSort(arr,l,i-1); quickSort(arr,j+1,r); &#125; return arr; &#125;&#125;function main()&#123; var list=new Array(49,38,65,97,76,13,27); document.write(sort(list).valueOf());&#125;main(); 7.插入排序 即将序列中的第一个元素看成一个有序的子序列，然后不段向后比较交换比较交换。 1234567891011121314function insertSort(arr)&#123; var key; for(var j = 1; j &lt; arr.length ; j++)&#123; //排好序的 var i = j - 1; key = arr[j]; while(i &gt;= 0 &amp;&amp; arr[i] &gt; key)&#123; arr[i + 1] = arr[i]; i --; &#125; arr[i + 1] = key; &#125; return arr;&#125; 8.希尔排序 也称递减增量排序算法 1234567891011121314151617181920212223242526272829303132333435363738function shellSort(array)&#123; var stepArr = [1750, 701, 301, 132, 57, 23, 10, 4, 1]; // reverse()在维基上看到这个最优的步长较小数组 var i = 0; var stepArrLength = stepArr.length; var len = array.length; var len2 = parseInt(len/2); for(;i &lt; stepArrLength; i++)&#123; if(stepArr[i] &gt; len2)&#123; continue; &#125; stepSort(stepArr[i]); &#125; // 排序一个步长 function stepSort(step)&#123; //console.log(step) 使用的步长统计 var i = 0, j = 0, f, tem, key; var stepLen = len%step &gt; 0 ? parseInt(len/step) + 1 : len/step; for(;i &lt; step; i++)&#123; // 依次循环列 for(j=1;/*j &lt; stepLen &amp;&amp; */step * j + i &lt; len; j++)&#123; //依次循环每列的每行 tem = f = step * j + i; key = array[f]; while((tem-=step) &gt;= 0)&#123; // 依次向上查找 if(array[tem] &gt; key)&#123; array[tem+step] = array[tem]; &#125;else&#123; break; &#125; &#125; array[tem + step ] = key; &#125; &#125; &#125; return array;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"前端知识大乱炖（转）","date":"2017-03-28T01:09:12.000Z","path":"2017/03/28/前端打乱炖（转）/","text":"声明：放到博客里是为了方便自己阅读，主要是入门以及提高的方法，参考书籍来源: https://github.com/qiu-deqing/FE-learning FE-learning 必备基础技能 基本开发工具 学习方法和学习目标 入门之路 继续提高 一些个人经历 LingyuCoder的学习经历 工具 技能 语言基础 进阶 项目 未来 其他 入门书 一些不错的网站 历程 MrRaindrop的学习经历 缘起 项目，下一个项目 收集癖和知识管理 跟对神 读书 前端的定位 最后 byr论坛yiyizym的建议 必备基础技能前端技能汇总这个项目详细记录了前端工程师牵涉到的各方面知识。在具备基本技能之后可以在里面找到学习的方向，完善技能和知识面。 frontend-dev-bookmarks是老外总结的前端开发资源。覆盖面非常广。包括各种知识点、工具、技术，非常全面。 以下是个人觉得入门阶段应该熟练掌握的基础技能： HTML4，HTML5语法、标签、语义 CSS2.1，CSS3规范，与HTML结合实现各种布局、效果 Ecma-262定义的javascript的语言核心，原生客户端javascript，DOM操作，HTML5新增功能 一个成熟的客户端javascript库，推荐jquery 一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟， HTTP 在掌握以上基础技能之后，工作中遇到需要的技术也能快速学习。 基本开发工具恰当的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并解决问题，以下是个人觉得必备的前端开发工具： 文本编辑器：推荐Sublime Text，支持各种插件、主题、设置，使用方便 浏览器：推荐Google Chrome，更新快，对前端各种标准提供了非常好的支持 调试工具：推荐Chrome自带的Chrome develop tools，可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等 辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools， 翻墙工具：lantern, 壁虎漫步（已被和谐） 学习方法和学习目标方法： 入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果 在具备一定基础之后可以上网搜各种教程、demo，了解各种功能的实际用法和常见功能的实现方法 阅读HTML，CSS，Javascript标准全面完善知识点 阅读前端牛人的博客、文章提升对知识的理解 善用搜索引擎 目标： 熟记前面知识点部分的重要概念，结合学习经历得到自己的理解 熟悉常见功能的实现方法，如常见CSS布局，Tab控件等。 入门之路以下是入门阶段不错的书籍和资料 HTML先看《HTML &amp; CSS: Design and Build Websites》1-9章，然后《HTML5: The Missing Manual》1-4章。 CSS先看《CSS: The Missing Manual》，然后《CSS权威指南》 javascript先看《javascript高级程序设计》，然后《javascript权威指南》 HTTP看HTTP权威指南 在整个学习过程中HTML CSS JavaScript会有很多地方需要互相结合，实际工作中也是这样，一个简单的功能模块都需要三者结合才能实现。 动手是学习的重要组成部分，书籍重点讲解知识点，例子可能不是很充足，这就需要利用搜索引擎寻找一些简单教程，照着教程实现功能。以下是一些比较好的教程网址 可以搜索各大公司前端校招笔试面试题作为练习题或者他人总结的前端面试题还有个人总结的面试题（带参考答案） http://code.tutsplus.com有各种各样的教程 MDN也有很多教程，更重要的是里面有详细的文档，需要查找某个功能时在Google搜索：xxx site:https://developer.mozilla.org http://www.html5rocks.com/zh/也有很多优质教程 http://www.sitepoint.com/ http://alistapart.com/ 原生javascript是需要重点掌握的技能，在掌握原生javascript的基础上推荐熟练掌握jQuery，在实际工作中用处很大，这方面的书籍有《Learning jQuery》或者去jQuery官网 建一个https://github.com/账号，保存平时学习中的各种代码和项目。 有了一定基础之后可以搭建一个个人博客，记录学习过程中遇到的问题和解决方法，方便自己查阅也为其他人提供了帮助。也可以去http://www.cnblogs.com/或者http://www.csdn.net/这样的网站注册账号，方便实用 经常实用Google搜索英文资料应该经常找到来自http://stackoverflow.com/的高质量答案，遇到问题可以直接在这里搜索，如果有精力，注册一个账号为别人解答问题也能极大提高个人能力。 经典书籍熟读之后，可以打开前面必备基础技能部分的链接。认真读对应标准，全面掌握知识 继续提高有了前面的基础之后，前端基本算是入门了，这时候可能每个人心中都有了一些学习方向，如果还是没有。可以参考前面必备技能部分提到的那两个项目，从里面选一些进行发展学习。以下是一些不错的方面： Grunt：前端自动化工具，提高工作效率 less css：优秀的CSS预处理器 bootstrap：优秀的CSS框架，对没有设计师的团队很不错，与less结合使用效果完美 requirejs：AMD规范的模块加载器，前端模块化趋势的必备工具 Node.js：JavaScript也可以做后台，前端工程师地位更上一步 AngularJS：做Single Page Application的好工具 移动端web开发：智能手机的普及让移动端的流量正在逐步赶超PC端 Javascript内存管理：SPA长期运行需要注意内存泄露的问题 High Performance JavaScript(Build Faster Web Application Interfaces) Best Practices for Speeding Up Your Web Site：重要技能 一些个人经历LingyuCoder的学习经历上面的大神都总结得差不多了，我这里就胡扯一些吧 ####工具 chrome dev tools：前端开发调试利器，着重注意几个功能： console（废话） elements:元素样式调整，很常用 sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象 watch expression：通过表达式查看当前内存中的值 call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候） scope variables：作用域链上的变量，非常有用 network：抓包查看每个请求，非常重要，前后端联调必备 timeline：分析渲染、js执行等等各个阶段，性能优化利器 emulation：模拟移动端环境，mobile页面开发必备 一些插件: liveload: 修改页面后自动刷新，不用按F5 dimensions：直接在页面上测量的利器 livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中 image tool：测量，取色 UC二维码：移动端调试扫码必备 pagespeed，YSlow：页面性能分析和优化插件 马克飞象：优秀的在线markdown编辑器，快速写周报，做记录 sublime text3：编码方便，插件多，速度快，性能好 emmet：提升html编码速度必备 sublimelinter + 各种语言的lint和hint：代码纠错 一些snippets：自动补全，提升开发效率 Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能 Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件 GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子 iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备 Charles：Mac 平台最好用的抓包分析工具 Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用 Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便 ####技能前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说 #####语言基础JavaScript： 作用域链、闭包、运行时上下文、this 原型链、继承 NodeJS基础和常用API CSS： 选择器 浏览器兼容性及常见的hack处理 CSS布局的方式和原理（盒子模型、BFC、IFC等等） CSS 3，如animation、gradient、等等 HTML： 语义化标签 #####进阶JavaScript: 异步控制（Promise、ES6 generator、Async） 模块化的开发方式（AMD、CMD、KMD等等） JavaScript解释器的一些相关知识 异步IO实现 垃圾回收 事件队列 常用框架使用及其原理 jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研 AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦 underscore：优秀的工具库，方便的理解常用工具代码片段的实现 polymer/React: 组件化开发，面向未来，理解组件化开发的原理 CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理 DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程 解析HTML、CSS、JavaScript时造成的阻塞 HTML5相关 SVG及矢量图原理 Canvas开发及动画原理（帧动画） Video和Audio flex box布局方式 icon fonts的使用 常用NodeJs的package： koa express underscore async gulp grunt connect request 一些理念： 响应式Web 优雅降级、渐进增强 don’t make me think 网页可用性、可访问性、其中的意义 SEO搜索引擎优化，了解搜索引擎的原理 SPA的好处和问题 性能优化： 减少请求数量（sprite、combo） 善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式） 减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离） CSS的回流与重绘 #####项目 版本管理：首推Git，用过Git都不会想用SVN了 Git：本地版本管理的机制 SVN：远程中心的版本管理机制 自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并 Gulp：基于流构建，速度快、模块质量好 Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高 预处理和模板引擎 less：语法简单，但功能有限 jade、ejs、velocity等模板引擎，各有各的长处 coffee：python工程师最爱，我没用过 环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了 本地代理：ihosts 自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果 jasmine mocha 生态系统 npm bower spm 搭建一个属于自己的博客 git pages hexo jekyll #####未来 Web Componets：面向未来的组件化开发方式 HTML模板 Shadow DOM Custom Elements HTML Import 移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发 #####其他有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方 对于业务的思考：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务 交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目 知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录 对新技术的渴望，以及敢于尝试 ####入门书入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书： 《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看 《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助 《编写可维护的JavaScript》 《JavaScript DOM编程艺术》学习JavaScript和DOM开发的必读之作。 《Node.js开发指南》：不错的Nodejs入门书籍 《深入浅出Node.js》：Nodejs进阶书籍，必备 《JavaScript异步编程》：理解JS异步的编程理念 《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书 《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西 《Don`t make me think》：网页设计的理念，了解用户行为，非常不错 《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题 《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习 《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助 《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识 《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想 《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门 ####一些不错的网站 github：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习 codepen：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件 echojs：快速了解js新资讯的网站 stackoverflow和segmentfault：基本上各种问题都能在上面获得解答 google web fundamentals：每篇文章都适合仔细阅读 static files：开放的CDN，很好用 iconfont：阿里的矢量图标库，非常不错，支持CDN而且支持项目 html5 rocks: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章 css tricks：如何活用CSS，以及了解CSS新特性，这里可以满足你 JavaScript 秘密花园 JavaScript初学必看，非常不错 w3cplus：一个前端学习的网站，里面的文章质量都挺不错的 node school：一个不错的node学习网站 learn git branch：一个git学习网站，交互很棒 前端乱炖：一个前端文章分享的社区，有很多优秀文章 正则表达式：一个正则表达式入门教程，非常值得一看 阮一峰的博客和张鑫旭的博客：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源 各路大牛的博客：这个太多了，就不贴了，知乎上有很全的 各种规范的官方网站，不懂得时候读规范 ####历程以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和W3C School上的教程，以及一些前端博客，如汤姆大叔的博客。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了… MrRaindrop的学习经历应qiu神的邀请分享一下前端学习经验，这里对前端知识体系架构就不做总结了，各位大神们的总结已经相当到位了，我就贡献几个个人认为还比较有用的链接大家研究研究就好，然后主要分享一下我在前端学习过程中遇到的问题和总结的经验教训吧，如果能帮到想要入门的FE初学者（我就姑且假定为本文的读者受众类型了），让他们少走点弯路，每走一步都知道自己下一步的方向，这是最好了。各位大神的总结和分享详见qiu神整理的FE-learning。 先说下，前端这个东西每个人都可以有适合自己的学习方法，这篇仅作参考，写的有点乱，各位凑合看。 缘起我是属于误打误撞进了前端，之前一直往做游戏的方向去来着，搞过游戏网站，玩过游戏引擎，比如unity，unreal这种商业引擎，捣鼓了几个游戏原型，不过自打研一进了实验室，直接就被导师派去写了js，导师给了我半个月时间让我写个基于百度地图api的数据展示页面，虽然这个时间还是相当宽裕的，不过之前没怎么写过js，也不会用地图api，于是我就一边啃着《Javascript权威指南》（犀牛书）一边参考实验室前人留下的“代码”，总算是把功能都写出来了。那个页面算我的js入门作了，也是我前端学习路线的开始。 现在想来，虽然指派了去做前端，但是一直做下去并做好还是得靠兴趣维持，当然前端是一个趣味性十足的技术领域，而且社区每天都很“热闹”。 项目，下一个项目我个人认为前端的学习，初学阶段你可以完全脱离开书本，以项目驱动。虽然我个人是从犀牛书开始啃的，不过如果你没有充足的时间，或者觉得啃大部头乏而无味的话，还是别像我这样。当然了如果决定啃书最好是把书里的例子都跟着敲一遍的。我上研之前没接触过js，4月份还没开学呢就被直接被导师甩了个百度地图api的项目到脸上，接着就是各种ERP，地图数据展示，虽然换着花样来一点不重样，不过基本上都是前端的活，SSH和android开发也打过酱油，整个实验室就我一个人写前端敢信？富客户端SPA时代的后端就是一个restful接口，代码量基本都在前端啊，写的我一个人怎一个爽字了得…期间跟着导师感受了一把创业，每天从7点搞到晚上10点，也算是经历了一段快速成长期。 掌握一门技术先掌握它的大体框架，想一个能实现的点子，做一个能跑就行的demo，再去完善它的细节，等到demo完成了，对这门技术有了一个感性的认识，再去啃书，收获会大很多。我从开始原生js写到jquery，再到extjs，再到angularjs，从导师指定技术，到自己做技术选型，一个项目接着一个项目的练，就跟打怪升级似的。当然没有项目就去自己创造项目，动手实现自己的想法是件有乐趣和成就感的事。 收集癖和知识管理前端学习有个特点，很多东西都很零碎，分散，需要你自己去整理、归纳和总结。在微博、知乎上follow了众多的大神，你不仅仅是为了听八卦，大神们的只言片语有时候留下的是无尽的余味，很有可能一个不经意提到的一个词就成为你下一个学习的目标。收集这些信息，善用google，提问，思考。就像游戏里的收集要素，前端学习也是充满搜集要素的一个“游戏”，只不过你需要一个知识管理工具来充当物品栏和仓库，我所知道的大牛们无一不是知识管理工具的重度使用者。以前用的oneNote，那时候还没绑定到云存储，现在基本上用evernote，笔记已经累计到1200+篇。书签一直打算用delicious，因为它是基于tag管理的，但一直没用起来。当然重点不在于这些工具，但是趁手的工具可以提高你的学习效率。最关键当然是随时保持旺盛的学习欲望，你的目标是了解有关前端的一切（当然不是所有都要掌握，因为毕竟你的精力有限，而且现实的说这也不太可能）。 跟对神这个可控性貌似不大…跟对老大这个就不多说了，一定程度要看造化。不过话说回来，多跟身边的高手交流是王道，这个高手不一定要多高，但是一定要对技术有热情。研一的时候热情高涨，每天7点进实验室门，然后发现有个家伙居然比我还早到。后来发现这家伙上午就走了，下午又来了，而且导师对此习以为常，原来这家伙晚上不睡觉通宵写代码，上午才跑回去睡。后来经常和这位神讨论问题，每次感觉经验值蹭蹭蹭的往上涨。然后实验室还有一位神，被前面这位通宵神形容为“只能望其项背，一直在追赶，从来没赶上”，两位神的特点都是什么都了解一点，所以什么都能跟你讨论得起来，我有段时间做了个读书计划，从c/c++到vc/mfc再到unix网络编程，最后一路看到java核心技术和MSDN上的C#编程指南，和神们也能扯得很high了。 总之就是这两位神把我拉进了坑，或者说从一个坑跳进另一坑，虽然两位神都不是搞前端的，不过技术之间总有相通之处。 读书读书，多读书，读好书。在刘未鹏的博客里看到过一个公式，你第一个月的工资等于之前买过（读过）的技术书价格总和（这里说的技术书指那些经典的公认的好书）。讨论这个公式的正确性似乎没什么意义，然而它的合理性是毋庸置疑的，那就是多读经典技术书。最极端的一个例子，google的徐宥在我的大学里面说他扫荡了图书馆的整个TP312书架…对于前端的经典书籍，后面列了一个我收集的前端书列（如果有遗漏的前端经典好书，还请留言告诉我），有条件可以尝试刷一遍这些书，我也是在找完整的时间去啃完它们。之前说的，前端知识点松散，收集零散的知识点，从博客里快速学习等，这些只是前端学习的一个方面，如果你要想深入理解一个知识体系，了解它的来龙去脉，对它建立系统认识，读经典书还是必不可少的。 我从最开始啃完犀牛书，然后接着去看了其他一些和前端干系不大的经典技术书，再后来通过实验室的项目和自己弄的一些小项目逐渐对前端领域比较上路以后，又看了《Javascript模式》、《Javascript设计模式》、《编写可维护的Javascript》，后来了解到node并开始用node搞点小玩意儿，又看了本《NodeJS up and run》和《Mongodb权威指南》，不过感觉前者略坑。那会儿朴灵那本深入浅出（晒书么么哒）还没出，后来出了就去图书馆借来看完，这么看下来感觉还不错，不过感觉看的还是偏少了，还需要继续刷（参照上面的书列）。 前端的定位前端的定位关乎到你需要吸收什么样的知识和技能，决定在技术世界里你对什么需要格外敏感。如果你认为前端仅仅停留在切页面，实现交互和视觉的要求，那你对前端的认识还停留在初级阶段。阿里终面的时候我问了考官这么个问题：前端技术日新月异，范围越扩越宽，标准越来越丰富，似乎任何一个触角都能伸出很远。怎么给前端一个合适的定位？考官给我分析了半天，然后总结成一句话，就是用户和网站的联结者，用户体验的创造者（原话不是这样，但大体是这个意思）。也就是说前端的终极目标其实就是创造用户体验，提升用户体验，以用户体验为中心。不管你是从交互设计上下手，还是从性能优化出发，或者改进工作流提升工作流效率，最终都是为了创造和提升用户体验，最终都要体现到用户体验这一点上来。我认为这个总结非常有道理（当然“用户体验”这个词太宽泛了，并且不仅仅是前端工程师的范畴，比如开发后台的时候对一个数据处理过程进行优化，提升了整体性能，这也是对用户体验的一个提升）。 现在的前端工程师做到一定阶段不可避免会接触到很多比切页面、实现视觉要求、实现交互等更深入的问题，比如前端自动化、图像编程、性能优化等等，再往后推一点就是PHP/JSP/ASP/nodeJs，过去后端模板一般属于后端的范畴，现在随着前端架构的演进，可能会让你去写后端模板的代码，需要用到后端语言（PHP/Java/C#等），这就是所谓大前端（然而这与前端的定位并不是相背离的，大前端处理的依然是与用户接触的部分，仍然是对用户体验的优化）。可能最常见或者被谈论最多的就是node，其实这几种技术选型都可以，bat三家据说百度用PHP比较多，阿里用node比较多。 玉伯在他的博客里提过所谓全端是横向的，全栈是纵向的。全端即所有的终端说白了都是前端，因为都关乎到用户体验，直接和用户接触。适应多终端的开发，要求你在web前端的基础上，可能还要去扩展android开发和ios开发的知识，好在由于hybrid开发方式的流行，对使用native语言开发的技能会要求的不那么深入。 全栈可以说是最适合初创公司的一种发展类型，广义上认为是从前端干到后端，从开发干到运维，这种就不说了，一般人应该不会想要去往这个方向发展，想要成为这种意义上的full-stack dev的，可能用不着来看我这篇文章了；而狭义上的全栈特指使用js语言从前端写到架设在nodeJs上的后端，前后端统一语言，统一编程模型，甚至公用同一套代码。更多了解全栈开发可以看看玉伯这篇说说全栈工程师。 以上是我对前端以及衍生出来的技术路线的一些浅薄理解，学习一个领域掌握它的整体上的走向和趋势还是挺重要的。另外如果想要对前端学习方向、职业成长路径有一个整体的认识，推荐看看拔赤总结的这篇前端开发十日谈。 最后贡献几个对前端学习、面试有帮助的链接： 前端面试问题合集（Front-end-Developer-Interview-Questions） 前端技能汇总（JacksonTian） 另一张前端技能汇总图 前端那点事儿（书列） byr论坛yiyizym的建议与grunt相比，学习gulp会比较简单 做SPA的话，推荐backbone.js和 backbone.marionette.js 翻墙不用折腾，花十块钱买一个月的 红杏。 把基础打扎实了再学这些都没问题。 html 没什么好说的，有空学学html5。 css 尽量看文档 ，因为很多中文资料都各执一辞，看多了反而会糊涂。 有个网站可以查找html/css标签、属性在各个浏览器中的支持情况，挺好用的。 javascript 就看 javascript高级程序设计 。不过这么厚的书看过就会忘。对javascript核心概念的讲解：对象/原型链/ 构造函数/执行上下文/作用域链/闭包/this，这里有篇不错的文章。 有闲情可以看看 ecmascript 6。阮一峰的网站有入门资料。 jquery 有很多 API,这个网站可以方便查到。有时间弄清楚jquery deferred 的用法。 多给 sublimetext 装插件，比如说检查代码错误的，新建目录文件的，整理代码的。","categories":[{"name":"direct","slug":"direct","permalink":"http://yoursite.com/categories/direct/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]}]